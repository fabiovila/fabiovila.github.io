{
    "version": "https://jsonfeed.org/version/1",
    "title": "Fabio",
    "description": "",
    "home_page_url": "https://fabiovila.github.io",
    "feed_url": "https://fabiovila.github.io/feed.json",
    "user_comment": "",
    "author": {
        "name": "Fabio"
    },
    "items": [
        {
            "id": "https://fabiovila.github.io/rede-neural-em-python-numpy-para-iris-dataset.html",
            "url": "https://fabiovila.github.io/rede-neural-em-python-numpy-para-iris-dataset.html",
            "title": "Rede neural em python numpy para iris dataset",
            "summary": "O entendimento de como funciona o treinamento das redes neurais é um processo difícil por envolver conhecimentos de diversas áreas e matemática de nível superior. E mesmo para quem tem cálculo 1 e 2 quando se depara com a derivação parcial do erro com base&hellip;",
            "content_html": "<p>O entendimento de como funciona o treinamento das redes neurais é um processo difícil por envolver conhecimentos de diversas áreas e matemática de nível superior. E mesmo para quem tem cálculo 1 e 2 quando se depara com a <em>derivação parcial do erro com base nos pesos</em> o entendimento não é trivial.</p>\n<p>Ainda ficarei devendo essa explicação completa, mas enquanto isso segue este programa que fiz para python/numpy para treinar o dataset Iris usando duas camadas de redes neurais ativadas por sigmoide e treinadas usando retro-propagação com AdaGrad.</p>\n<p>Sem o AdaGrad o treinamento se torna instável e pode ficar preso em um minimo local e nunca mais sair.</p>\n<p>A convergência do Erro vai depender de cada execução devido a inicialização aleatória dos pesos, pode acontecer até mesmo de ainda sim ficar preso em um minimo local e não sair mais. Basta executar novamente que novos pesos aleatórios são inicializados.</p>\n<p><a href=\"https://fabiovila.github.io/iris.data.csv\" target=\"_blank\" rel=\"noopener noreferrer\" download>Link para download do iris dataset.</a></p>\n<pre><code class=\"language-python\">\nimport numpy as np\n\n# Ativação sigmoid\ndef sig(n):\n    return 1 / ( 1 + np.exp(-n))\n\n# Derivada da sigmoid\n# Muitos empacam aqui porque envolve cálculo 1 e 2 que só se aprende na faculdade\ndef dsig(n):\n    return n * ( 1 - n)\n\n\nif __name__ == '__main__':\n    np.set_printoptions(precision=2 , suppress=True)\n\n    # o iris.data.csv está organizado da seguinte forma:\n    # 5.1,3.5,1.4,0.2,Iris-setosa\n    # 4.9,3.0,1.4,0.2,Iris-setosa\n    # 4.7,3.2,1.3,0.2,Iris-setosa\n    #\n\n    # carrega as quatro primeiras colunas que são os valores coletados na pesquisa\n    X       = np.loadtxt('iris.data.csv', delimiter=',', usecols=[0,1,2,3])\n    # carrega a última coluna contendo a string que define a categoria\n    labels  = np.loadtxt('iris.data.csv', delimiter=',', dtype=str, usecols=[4])\n    # Transforma as strings em valores númericos únicos\n    l, Yu   = np.unique(labels, return_inverse=True)\n    # e finalmente indexa cada valor numerico em um vetor 3 (ou matriz 1x3) \n    Y       = np.array([[0.0,0.0,1.0],[0.0,1.0,0.0],[1.0,0.0,0.0]])[Yu]\n    \n    r = np.random.randint(0,len(X),size=5)\n    for rr in r:\n        print (\"X:\" + str(X[rr]) + \" Yu: \" + str(Yu[rr]) + \" Y: \" + str(Y[rr]) + \" Label: \" + str(labels[rr]) )\n    \n    # logo os dados serão apresentados da seguinte forma para a rede neural\n    # [5.1,3.5,1.4,0.2] - [1.0,0.0,0.0]\n\n\n    # Dados armazenados, hora de montar a rede neural\n\n    Wx = np.random.uniform(-5.0,5.0, size = (4,8))\n    Bx = np.zeros((1,8))\n\n    Wy = np.random.uniform(-5.0,5.0, size = (8,3))\n    By = np.zeros((1,3))\n\n    AWx = np.zeros((4,8))\n    ABx = np.zeros((1,8))\n\n    AWy = np.zeros((8,3))\n    ABy = np.zeros((1,3))\n\n    # faz uma breve previsão com a rede destreinada para observar os cálculos. O Forward\n    ox =  sig(X[0] @ Wx + Bx)  # multiplicação de matrizes de X[0] com Wx e soma Bx o resultado é uma matrix e 1 linha e 8 colunas\n    oy =  sig(ox @ Wy + By) \n    print(ox , oy)\n\n    #let's cooking! vamos treinar a rede!\n    lrate = 0.35\n    for epoch in range(10000):\n        # gera uma sequencia aleatória para ser usada como indice no próximo for\n        # dessa forma os dados serão apresentados a rede de forma aleatória do que na sequência natural do arquivo\n        Xr = np.random.permutation(len(X))\n        et = 0  # erro total\n        #lrate = lrate * 0.9999\n        for ite in Xr:\n            Xi = X[ite]\n            Yi = Y[ite]\n\n\n\n            ## o forward\n\n            ox =  sig(Xi @ Wx + Bx)  # multiplicação de matrizes de X[0] com Wx e soma Bx o resultado é uma matrix e 1 linha e 8 colunas\n            oy =  sig(ox @ Wy + By)\n\n\n            ## o backward\n\n            # o erro dessa interação\n            e = oy - Yi \n            # a soma dos erros de todas a interações\n            et += (e*e).sum()\n\n            b = e * dsig(oy)\n            delta = np.outer(ox,b)\n\n            AWy += np.multiply(delta,delta)\n            ABy += b*b\n\n            Wy -= lrate * delta / np.sqrt(AWy + 1e-6)\n            By -= lrate * b  / np.sqrt(ABy+1e-6)\n\n\n\n            # propaga o erro para a camada x\n            ex = e @ Wy.T\n\n            # e finalmente atualiza a primeira camada\n            b = ex * dsig(ox)\n            delta = np.outer(Xi,b)\n\n            AWx += np.multiply(delta,delta)\n            ABx += b*b\n\n            Wx -= lrate * delta / np.sqrt(AWx+1e-6)\n            Bx -= lrate * b  / np.sqrt(ABx+1e-6)\n\n\n\n        print (\"Erro: %4.4f Learning Rate: %4.4f\"%(et,lrate))\n        #input()\n            \n\n    for n,xx in enumerate(X):\n        ox =  sig(xx @ Wx + Bx)  \n        oy =  sig(ox @ Wy + By)\n        print (\"X:\" + str(xx) + \" Y: \" + str(Y[n]) + \" Output: \" + str(oy) )</code>  </pre>",
            "author": {
                "name": "Fabio"
            },
            "tags": [
                   "redes-neurais",
                   "python",
                   "numpy",
                   "machine-learning"
            ],
            "date_published": "2021-06-02T11:41:47-03:00",
            "date_modified": "2021-06-02T14:17:13-03:00"
        },
        {
            "id": "https://fabiovila.github.io/fazendo-um-cardapio-de-cafe-da-manha-com-calorias-e-baixo-custo-no-or-tools.html",
            "url": "https://fabiovila.github.io/fazendo-um-cardapio-de-cafe-da-manha-com-calorias-e-baixo-custo-no-or-tools.html",
            "title": "Fazendo uma dieta de café da manhã de baixo custo no OR-TOOLs",
            "summary": "Dietas com restrições Um problema comum na nutrição é a confecção de dietas com restrições. As restrições podem ser calóricas ou com ausência de algum componente como a lactose, a gordura, o glúten, etc .... Em geral o custo destas dietas aumentam em relação a&hellip;",
            "content_html": "<h2>Dietas com restrições</h2>\n<p>Um problema comum na nutrição é a confecção de dietas com restrições. As restrições podem ser calóricas ou com ausência de algum componente como a lactose, a gordura, o glúten, etc ....</p>\n<p>Em geral o custo destas dietas aumentam em relação a dieta comum. Para auxiliar na procura de uma dieta barata neste post faremos uma dieta abaixo de uma dada caloria e com menor custo possível usando o otimizador OR-TOOLs.</p>\n<p><em>Apesar do título esse post (e meu blog) trata de um exemplo de uso do otimizador OR-TOOLs em Python e tem tópicos de matemática. Se você chegou aqui e é da área da nutrição provavelmente se perderá, porém ao menos ficará o conhecimento intuitivo do uso de softwares para se fazer dietas.</em></p>\n<h6>Quantidades praticáveis</h6>\n<p>O problema de escolher certos alimentos reduzindo o custo é um problema semelhante ao knapsack. Onde é dado uma lista de alimentos com seus valores calóricos e custos e uma quantidade de calorias máxima e minima que deverão ser respeitados. O objetivo é minimizar o custo da dieta. </p>\n<p>Um dos problemas a se resolver é a quantidade impraticável. Não há como quantificar 1.01 ou 0.04 de um Ovo, a dieta deve conter quantidades praticáveis de cada alimento.</p>\n<p>Há várias forma de se resolver isso. Uma delas é repetir o alimento com quantidades fracionadas e seguras. Dessa forma teremos $X_{?} - Ovo Inteiro, X_{?} - Meio Ovo$ e assim vai. É uma forma segura pois cada alimento tem fracionamento diferente como por exemplo o Leite que pode ser 1 Copo, 100mL, 1L, 0.1 Litros, 240mL em contraste com o Ovo que só faz sentido valores inteiros.</p>\n<p>Entretanto um aumento no número de variáveis degrada a performance do solver. Mas não podemos esquecer que em um ambiente de produção a Nutricionista irá selecionar previamente os alimentos possíveis e ainda deve-se levar em conta que em um café da manhã não se tem muitas opções disponíveis o que torna o problema resolvível em tempo hábil.</p>\n<p>Em um ambiente de produção quando a pessoa seleciona Ovo o programa automaticamente trabalha com Ovo inteiro e Meio Ovo. Para evitar que Meio Ovo seja usado mais de uma vez (o que daria um ovo inteiro) podemos restringir o Meio Ovo para somente 1 unidade, entretanto Ovo Inteiro pode ser usado indefinidamente unidades inteiras.</p>\n<h6>O problema</h6>\n<p>O modelo matemático deste problema é </p>\n<div class=\"defin\">\n<p>Dados:</p>\n<p>$V_{i}$ - Valor calórico do alimento $i$<br><br>$C_{i}$ - Custo em Reais do alimento $i$<br><br>$K$ - Calorias máximas da dieta</p>\n<p>$Km$ - Calorias minimas da dieta</p>\n<p>$X_{i}$ - Variável de decisão que indica a quantidade do alimento $i$ na dieta, não pode ser Reais pois podemos ter como resultado valores fracionários impraticáveis em alguns alimentos como ovos, pão, queijos.</p>\n<p>$X_{i}\\leq4$ - Limitamos o número de cada alimento para evitar monotonia da dieta</p>\n<p>Onde queremos:</p>\n<p>$\\quad\\min(\\sum\\nolimits_{X_{i}C_{i}})$</p>\n<p>$\\quad\\text{sujeito a:}$</p>\n<p>$\\quad\\sum\\nolimits_{X_{i}V_{i}}\\leq K$</p>\n<p>$\\quad\\sum\\nolimits_{X_{i}V_{i}}\\geq Km$</p>\n<p>$\\quad X_{i}\\in \\{0, 0.5, 1, 1.5 , 2 , 2.5 , 3 , 3.5, 4\\}$</p>\n</div>\n<p>$X_{i}$ deve ser maior ou igual a 0 e limitamos os valores para $\\{0, 0.5, 1, 1.5 , 2 , 2.5 , 3 , 3.5, 4\\}$ para impedir que um ovo tenha 1.01 ou 0.02 de quantidade e no máximo 4  quantidades do alimento para não sair uma dieta com poucos ou um alimento.</p>\n<p> </p>\n<p> </p>\n<p> </p>",
            "image": "https://fabiovila.github.io/media/posts/2/bread-18987_640.jpg",
            "author": {
                "name": "Fabio"
            },
            "tags": [
                   "python",
                   "otimização",
                   "cvxpy"
            ],
            "date_published": "2020-08-02T11:24:16-03:00",
            "date_modified": "2021-05-21T20:32:52-03:00"
        },
        {
            "id": "https://fabiovila.github.io/o-cvxpy-para-o-problema-de-mochila-knapsack.html",
            "url": "https://fabiovila.github.io/o-cvxpy-para-o-problema-de-mochila-knapsack.html",
            "title": "O CVXPY para o problema de mochila (knapsack)",
            "summary": "CVXPY CVXPY é um framework python para diversos otimizadores com uma linguagem própria e suporte a Numpy. Para instalar o CVXPY use o pip: pip install cvxpy Um dos otimizadores disponíveis é o CBC um otimizador de programação linear inteiro open-source. O CBC pode ser&hellip;",
            "content_html": "<h2>CVXPY</h2>\n<p>CVXPY é um framework python para diversos otimizadores com uma linguagem própria e suporte a Numpy.</p>\n<p>Para instalar o CVXPY use o pip:</p>\n<p><code class=\"language-bash\">pip install cvxpy</code></p>\n<p>Um dos otimizadores disponíveis é o <a href=\"https://projects.coin-or.org/Cbc\" target=\"_blank\" rel=\"noopener noreferrer\">CBC</a>  um otimizador de programação linear inteiro open-source. O CBC pode ser usado em linha de comando sem ser necessário o CVXPY, mas neste caso será necessário aprender sua linguagem de entrada. </p>\n<p>Também será necessário instalar o CVXOPT:</p>\n<p><code class=\"language-bash\">pip install cvxopt</code></p>\n<h2>Problema da mochila</h2>\n<p>O problema da mochila mais conhecido como knapsack é um problema clássico de otimização combinatória.</p>\n<p>O problema consiste em colocar o maior valor possível de itens em uma mochila com certa capacidade de peso. A mochila tem uma capacidade definida de peso. Os itens um peso e um valor. A objetivo é ter o maior valor possível dentro da mochila, ou seja, maximizar o valor.</p>\n<p>Esse problema aparece em diversas áreas como a logística, computação e investimentos.</p>\n<pre><code class=\"language-python\">import cvxpy as cp\nimport numpy as np\n# Dados de entrada do problema\nValores = np.array([10,13,1,100,45,13,156,76,4,59,97,99])\nPesos = np.array([50,55,10,5,1,98,34,3,9,3,7,19])\nCapacidade_Mochila = 100<br>\n# Variaveis de decisão<br>\n# Cada Item Xi terá valor 1 se estiver na mochila ou 0 se estiver fora\n# cp.Variable cria uma variável no CVX ( não confunda cp com np ) do tipo boolean do tamanho da quantidade de itens\n<br>Xi = cp.Variable((Valores.size), boolean = True)\n<br># Constraints do problema<br>\n# A soma total dos pesos dos itens escolhidos por Xi devem ser igual ou menor que a capacidade da mochila                \n<br>constraints = [ Xi @ Pesos &lt;= Capacidade_Mochila ]\n# Tambem pode ser escrito com o mesmo resultado como:\n#constraints = [ cp.sum( cp.multiply (Xi, Pesos ) ) &lt;= Capacidade_Mochila ]\n<br># O Objetivo do problema\n# é maximizar os valores na mochila<br>\nobjective = cp.Maximize( Xi @ Valores )\n<br># finalmente chamamos o solver com verbose para acompanhar \n# o progresso e a execução máxima de 1hr<br>\nprob = cp.Problem(objective, constraints)              \nprob.solve(solver=cp.CBC,verbose=True, maximumSeconds = 1 * 60 * 60)         \nprint(\"Status          : \", prob.status)\nprint(\"Valor encontrado: \", prob.value)\nprint(\"Valor de Xi     : \", Xi.value)\n    </code></pre>\n<p>O problema da mochila tem muitas aplicações práticas principalmente na logística. Imagine uma transportadora que precisa distribuir seus pacotes utilizando vans e caminhões. Cada pacote tem peso, tamanho, localidade, tempo de espera e valor. Um programa de otimização pode ajudar no preenchimento dos caminhões e em aplicações profissionais traçar a rota de distribuição de cada veículo.</p>\n<p>Problemas de otimização não acham o melhor valor, porque em geral é uma tarefa impossível (o mais correto seria improvável) de acha-lo devido a explosão combinatória. Por isso são chamados 'otimizadores' porque eles buscam a melhor solução possível, ou seja, uma solução ótima.</p>",
            "image": "https://fabiovila.github.io/media/posts/1/Screenshot-from-2021-05-15-17-39-07-2.png",
            "author": {
                "name": "Fabio"
            },
            "tags": [
                   "python",
                   "otimização",
                   "cvxpy"
            ],
            "date_published": "2020-07-26T15:35:10-03:00",
            "date_modified": "2021-06-02T13:47:21-03:00"
        }
    ]
}

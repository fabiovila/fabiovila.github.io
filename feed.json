{
    "version": "https://jsonfeed.org/version/1",
    "title": "Fabio",
    "description": "",
    "home_page_url": "https://fabiovila.github.io",
    "feed_url": "https://fabiovila.github.io/feed.json",
    "user_comment": "",
    "author": {
        "name": "Fabio"
    },
    "items": [
        {
            "id": "https://fabiovila.github.io/usando-raspberry-pi-como-servidor-syslog-remoto-para-roteador-claronet.html",
            "url": "https://fabiovila.github.io/usando-raspberry-pi-como-servidor-syslog-remoto-para-roteador-claronet.html",
            "title": "Usando Raspberry Pi como servidor syslog remoto para roteador Claro/NET",
            "summary": "Descobri esses dias que meu roteador Claro/NET tem a opção de log&hellip;",
            "content_html": "<p>Descobri esses dias que meu roteador Claro/NET tem a opção de log remoto. Aproveitei então meu Raspberry PI como servidor remoto syslog do roteador.</p>\n<h2>Configurando rsyslog</h2>\n<p>O servidor syslog usado será o rsyslog que já vem por padrão instalado no Raspberry PI OS serão apenas criar e mudar alguns arquivos.</p>\n<h2>Habilitando o servidor na porta 514 no RPI</h2>\n<p>Para habilitar o servidor rsyslog na port 514 edite o arquivo<code> /etc/rsyslog.conf</code> e descomente as seguintes linhas:</p>\n<pre><code># provides UDP syslog reception<br>module(load=\"imudp\")<br>input(type=\"imudp\" port=\"514\")<br><br># provides TCP syslog reception<br>module(load=\"imtcp\")<br>input(type=\"imtcp\" port=\"514\")</code></pre>\n<h2>Criando o arquivo de log</h2>\n<p>Você terá que especificar o arquivo e local que o log será acumulado, para isso crie o arquivo de log em /var/log com o nome desejado como no exemplo abaixo:</p>\n<pre><code>$ sudo touch /var/log/claro.log</code></pre>\n<h2>Configurando o rsyslog para seu arquivo de log</h2>\n<p>Agora é hora de criar um arquivo com qualquer nome mas terminado em <code>.conf </code>no local <code>/etc/rsyslog.d/</code> que indicará no arquivo de log e o IP do cliente (o roteador) que produzirá os logs:</p>\n<pre> <code class=\"language-shell\" data-lang=\"shell\">$template NetworkLog, \"/var/log/claro.log\"<br>:fromhost-ip, isequal, \"192.168.0.1\" -?NetworkLog<br>&amp; stop</code></pre>\n<p>Veja que <code>\"/var/log/claro.log\"</code> deverá ser igual ao arquivo criado do passo anterior e o IP o IP do seu roteador.</p>\n<h2>Rotate</h2>\n<p>Não é uma boa deixar o log crescer indefinidamente, então é melhor configurar o rotate do arquivo impondo um limite. Crie um arquivo com qualquer nome em /etc/logrotate.d/ e coloque o texto abaixo:</p>\n<pre><code class=\"language-shell\" data-lang=\"shell\">/var/log/claro.log { \n        rotate 7\n        size 500k\n        notifempty\n        compress\n        postrotate\n                invoke-rc.d rsyslog rotate &gt; /dev/null\n        endscript\n    }</code></pre>\n<h2>Reiniciando o rsyslog</h2>\n<p>Finalmente reinicie o rsyslog:</p>\n<pre><code class=\"language-shell\" data-lang=\"shell\">$ sudo service rsyslog restart</code></pre>\n<h2>Configurando o Roteador Claro/NET</h2>\n<p>Para configurar o roteador você deverá estar logado entrar em <strong>Configurações Avançadas </strong>e no Menu que aparecerá seguir o caminho <strong>Menu &gt; Segurança &gt; Firewall &gt; Log</strong> Remoto e a seguinte página será exibida:</p>\n<figure class=\"post__image\" ><img loading=\"lazy\" src=\"https://fabiovila.github.io/media/posts/7/Captura-de-tela-de-2021-07-09-21-09-27.png\" sizes=\"(max-width: 1024px) 100vw, 1024px\" srcset=\"https://fabiovila.github.io/media/posts/7/responsive/Captura-de-tela-de-2021-07-09-21-09-27-xs.png 300w ,https://fabiovila.github.io/media/posts/7/responsive/Captura-de-tela-de-2021-07-09-21-09-27-sm.png 480w ,https://fabiovila.github.io/media/posts/7/responsive/Captura-de-tela-de-2021-07-09-21-09-27-md.png 768w ,https://fabiovila.github.io/media/posts/7/responsive/Captura-de-tela-de-2021-07-09-21-09-27-lg.png 1024w\"  alt=\"Tela de configuração do roteador\" width=\"876\" height=\"1019\">\n<figcaption >Tela de configuração de LOG do roteador da Claro</figcaption>\n</figure>\n<p>No campo <strong>192.168.0.[   ]</strong> você deverá preencher com o final do IP do raspberry-pi rodando o rsyslog; escolher a opção \"<strong>PARA SERVIDOR SYSLOG EM:</strong>\" e finalmente nas opções de log desejadas.</p>\n<p>A quantidade de logs produzidas é grande.</p>\n<p> </p>",
            "author": {
                "name": "Fabio"
            },
            "tags": [
                   "segurança",
                   "rsyslog",
                   "raspberry-pi"
            ],
            "date_published": "2021-07-09T20:56:17-03:00",
            "date_modified": "2021-07-09T21:15:55-03:00"
        },
        {
            "id": "https://fabiovila.github.io/rede-neural-em-python-numpy-para-iris-dataset.html",
            "url": "https://fabiovila.github.io/rede-neural-em-python-numpy-para-iris-dataset.html",
            "title": "Rede neural em python numpy para iris dataset",
            "summary": "O entendimento de como funciona o treinamento das redes neurais é um&hellip;",
            "content_html": "<p>O entendimento de como funciona o treinamento das redes neurais é um processo difícil por envolver conhecimentos de diversas áreas e matemática de nível superior. E mesmo para quem tem cálculo 1 e 2 quando se depara com a <em>derivação parcial do erro com base nos pesos</em> o entendimento não é trivial.</p>\n<p>Ainda ficarei devendo essa explicação completa, mas enquanto isso segue este programa que fiz para python/numpy para treinar o dataset Iris usando duas camadas de redes neurais ativadas por sigmoide e treinadas usando retro-propagação com AdaGrad.</p>\n<p>Sem o AdaGrad o treinamento se torna instável e pode ficar preso em um minimo local e nunca mais sair.</p>\n<p>A convergência do Erro vai depender de cada execução devido a inicialização aleatória dos pesos, pode acontecer até mesmo de ainda sim ficar preso em um minimo local e não sair mais. Basta executar novamente que novos pesos aleatórios são inicializados.</p>\n<p><a href=\"https://fabiovila.github.io/iris.data.csv\" target=\"_blank\" rel=\"noopener noreferrer\" download>Link para download do iris dataset.</a></p>\n<pre><code class=\"language-python\">\nimport numpy as np\n\n# Ativação sigmoid\ndef sig(n):\n    return 1 / ( 1 + np.exp(-n))\n\n# Derivada da sigmoid\n# Muitos empacam aqui porque envolve cálculo 1 e 2 que só se aprende na faculdade\ndef dsig(n):\n    return n * ( 1 - n)\n\n\nif __name__ == '__main__':\n    np.set_printoptions(precision=2 , suppress=True)\n\n    # o iris.data.csv está organizado da seguinte forma:\n    # 5.1,3.5,1.4,0.2,Iris-setosa\n    # 4.9,3.0,1.4,0.2,Iris-setosa\n    # 4.7,3.2,1.3,0.2,Iris-setosa\n    #\n\n    # carrega as quatro primeiras colunas que são os valores coletados na pesquisa\n    X       = np.loadtxt('iris.data.csv', delimiter=',', usecols=[0,1,2,3])\n    # carrega a última coluna contendo a string que define a categoria\n    labels  = np.loadtxt('iris.data.csv', delimiter=',', dtype=str, usecols=[4])\n    # Transforma as strings em valores númericos únicos\n    l, Yu   = np.unique(labels, return_inverse=True)\n    # e finalmente indexa cada valor numerico em um vetor 3 (ou matriz 1x3) \n    Y       = np.array([[0.0,0.0,1.0],[0.0,1.0,0.0],[1.0,0.0,0.0]])[Yu]\n    \n    r = np.random.randint(0,len(X),size=5)\n    for rr in r:\n        print (\"X:\" + str(X[rr]) + \" Yu: \" + str(Yu[rr]) + \" Y: \" + str(Y[rr]) + \" Label: \" + str(labels[rr]) )\n    \n    # logo os dados serão apresentados da seguinte forma para a rede neural\n    # [5.1,3.5,1.4,0.2] - [1.0,0.0,0.0]\n\n\n    # Dados armazenados, hora de montar a rede neural\n\n    Wx = np.random.uniform(-5.0,5.0, size = (4,8))\n    Bx = np.zeros((1,8))\n\n    Wy = np.random.uniform(-5.0,5.0, size = (8,3))\n    By = np.zeros((1,3))\n\n    AWx = np.zeros((4,8))\n    ABx = np.zeros((1,8))\n\n    AWy = np.zeros((8,3))\n    ABy = np.zeros((1,3))\n\n    # faz uma breve previsão com a rede destreinada para observar os cálculos. O Forward\n    ox =  sig(X[0] @ Wx + Bx)  # multiplicação de matrizes de X[0] com Wx e soma Bx o resultado é uma matrix e 1 linha e 8 colunas\n    oy =  sig(ox @ Wy + By) \n    print(ox , oy)\n\n    #let's cooking! vamos treinar a rede!\n    lrate = 0.35\n    for epoch in range(10000):\n        # gera uma sequencia aleatória para ser usada como indice no próximo for\n        # dessa forma os dados serão apresentados a rede de forma aleatória do que na sequência natural do arquivo\n        Xr = np.random.permutation(len(X))\n        et = 0  # erro total\n        #lrate = lrate * 0.9999\n        for ite in Xr:\n            Xi = X[ite]\n            Yi = Y[ite]\n\n\n\n            ## o forward\n\n            ox =  sig(Xi @ Wx + Bx)  # multiplicação de matrizes de X[0] com Wx e soma Bx o resultado é uma matrix e 1 linha e 8 colunas\n            oy =  sig(ox @ Wy + By)\n\n\n            ## o backward\n\n            # o erro dessa interação\n            e = oy - Yi \n            # a soma dos erros de todas a interações\n            et += (e*e).sum()\n\n            b = e * dsig(oy)\n            delta = np.outer(ox,b)\n\n            AWy += np.multiply(delta,delta)\n            ABy += b*b\n\n            Wy -= lrate * delta / np.sqrt(AWy + 1e-6)\n            By -= lrate * b  / np.sqrt(ABy+1e-6)\n\n\n\n            # propaga o erro para a camada x\n            ex = e @ Wy.T\n\n            # e finalmente atualiza a primeira camada\n            b = ex * dsig(ox)\n            delta = np.outer(Xi,b)\n\n            AWx += np.multiply(delta,delta)\n            ABx += b*b\n\n            Wx -= lrate * delta / np.sqrt(AWx+1e-6)\n            Bx -= lrate * b  / np.sqrt(ABx+1e-6)\n\n\n\n        print (\"Erro: %4.4f Learning Rate: %4.4f\"%(et,lrate))\n        #input()\n            \n\n    for n,xx in enumerate(X):\n        ox =  sig(xx @ Wx + Bx)  \n        oy =  sig(ox @ Wy + By)\n        print (\"X:\" + str(xx) + \" Y: \" + str(Y[n]) + \" Output: \" + str(oy) )</code>  </pre>",
            "image": "https://fabiovila.github.io/media/posts/6/Captura-de-tela-de-2021-06-02-14-23-17.png",
            "author": {
                "name": "Fabio"
            },
            "tags": [
                   "redes-neurais",
                   "python",
                   "numpy",
                   "machine-learning"
            ],
            "date_published": "2021-06-02T11:41:47-03:00",
            "date_modified": "2021-06-02T14:23:31-03:00"
        },
        {
            "id": "https://fabiovila.github.io/fazendo-um-cardapio-de-cafe-da-manha-com-calorias-e-baixo-custo-no-or-tools.html",
            "url": "https://fabiovila.github.io/fazendo-um-cardapio-de-cafe-da-manha-com-calorias-e-baixo-custo-no-or-tools.html",
            "title": "Fazendo uma dieta de café da manhã de baixo custo no OR-TOOLs",
            "summary": "Dietas com restrições Um problema comum na nutrição é a confecção de&hellip;",
            "content_html": "<h2>Dietas com restrições</h2>\n<p>Um problema comum na nutrição é a confecção de dietas com restrições. As restrições podem ser calóricas ou com ausência de algum componente como a lactose, a gordura, o glúten, etc ....</p>\n<p>Em geral o custo destas dietas aumentam em relação a dieta comum. Para auxiliar na procura de uma dieta barata neste post faremos uma dieta abaixo de uma dada caloria e com menor custo possível usando o otimizador OR-TOOLs.</p>\n<p><em>Apesar do título esse post (e meu blog) trata de um exemplo de uso do otimizador OR-TOOLs em Python e tem tópicos de matemática. Se você chegou aqui e é da área da nutrição provavelmente se perderá, porém ao menos ficará o conhecimento intuitivo do uso de softwares para se fazer dietas.</em></p>\n<h6>Quantidades praticáveis</h6>\n<p>O problema de escolher certos alimentos reduzindo o custo é um problema semelhante ao knapsack. Onde é dado uma lista de alimentos com seus valores calóricos e custos e uma quantidade de calorias máxima e minima que deverão ser respeitados. O objetivo é minimizar o custo da dieta. </p>\n<p>Um dos problemas a se resolver é a quantidade impraticável. Não há como quantificar 1.01 ou 0.04 de um Ovo, a dieta deve conter quantidades praticáveis de cada alimento.</p>\n<p>Há várias forma de se resolver isso. Uma delas é repetir o alimento com quantidades fracionadas e seguras. Dessa forma teremos $X_{?} - Ovo Inteiro, X_{?} - Meio Ovo$ e assim vai. É uma forma segura pois cada alimento tem fracionamento diferente como por exemplo o Leite que pode ser 1 Copo, 100mL, 1L, 0.1 Litros, 240mL em contraste com o Ovo que só faz sentido valores inteiros.</p>\n<p>Entretanto um aumento no número de variáveis degrada a performance do solver. Mas não podemos esquecer que em um ambiente de produção a Nutricionista irá selecionar previamente os alimentos possíveis e ainda deve-se levar em conta que em um café da manhã não se tem muitas opções disponíveis o que torna o problema resolvível em tempo hábil.</p>\n<p>Em um ambiente de produção quando a pessoa seleciona Ovo o programa automaticamente trabalha com Ovo inteiro e Meio Ovo. Para evitar que Meio Ovo seja usado mais de uma vez (o que daria um ovo inteiro) podemos restringir o Meio Ovo para somente 1 unidade, entretanto Ovo Inteiro pode ser usado indefinidamente unidades inteiras.</p>\n<h6>O problema</h6>\n<p>O modelo matemático deste problema é </p>\n<div class=\"defin\">\n<p>Dados:</p>\n<p>$V_{i}$ - Valor calórico do alimento $i$<br><br>$C_{i}$ - Custo em Reais do alimento $i$<br><br>$K$ - Calorias máximas da dieta</p>\n<p>$Km$ - Calorias minimas da dieta</p>\n<p>$X_{i}$ - Variável de decisão que indica a quantidade do alimento $i$ na dieta, não pode ser Reais pois podemos ter como resultado valores fracionários impraticáveis em alguns alimentos como ovos, pão, queijos.</p>\n<p>$X_{i}\\leq4$ - Limitamos o número de cada alimento para evitar monotonia da dieta</p>\n<p>Onde queremos:</p>\n<p>$\\quad\\min(\\sum\\nolimits_{X_{i}C_{i}})$</p>\n<p>$\\quad\\text{sujeito a:}$</p>\n<p>$\\quad\\sum\\nolimits_{X_{i}V_{i}}\\leq K$</p>\n<p>$\\quad\\sum\\nolimits_{X_{i}V_{i}}\\geq Km$</p>\n<p>$\\quad X_{i}\\in \\{0, 0.5, 1, 1.5 , 2 , 2.5 , 3 , 3.5, 4\\}$</p>\n</div>\n<p>$X_{i}$ deve ser maior ou igual a 0 e limitamos os valores para $\\{0, 0.5, 1, 1.5 , 2 , 2.5 , 3 , 3.5, 4\\}$ para impedir que um ovo tenha 1.01 ou 0.02 de quantidade e no máximo 4  quantidades do alimento para não sair uma dieta com poucos ou um alimento.</p>\n<p> </p>\n<p> </p>\n<p> </p>",
            "image": "https://fabiovila.github.io/media/posts/2/bread-18987_640.jpg",
            "author": {
                "name": "Fabio"
            },
            "tags": [
                   "python",
                   "otimização",
                   "cvxpy"
            ],
            "date_published": "2020-08-02T11:24:16-03:00",
            "date_modified": "2021-05-21T20:32:52-03:00"
        },
        {
            "id": "https://fabiovila.github.io/o-cvxpy-para-o-problema-de-mochila-knapsack.html",
            "url": "https://fabiovila.github.io/o-cvxpy-para-o-problema-de-mochila-knapsack.html",
            "title": "O CVXPY para o problema de mochila (knapsack)",
            "summary": "CVXPY CVXPY é um framework python para diversos otimizadores com uma linguagem&hellip;",
            "content_html": "<h2>CVXPY</h2>\n<p>CVXPY é um framework python para diversos otimizadores com uma linguagem própria e suporte a Numpy.</p>\n<p>Para instalar o CVXPY use o pip:</p>\n<p><code class=\"language-bash\">pip install cvxpy</code></p>\n<p>Um dos otimizadores disponíveis é o <a href=\"https://projects.coin-or.org/Cbc\" target=\"_blank\" rel=\"noopener noreferrer\">CBC</a>  um otimizador de programação linear inteiro open-source. O CBC pode ser usado em linha de comando sem ser necessário o CVXPY, mas neste caso será necessário aprender sua linguagem de entrada. </p>\n<p>Também será necessário instalar o CVXOPT:</p>\n<p><code class=\"language-bash\">pip install cvxopt</code></p>\n<h2>Problema da mochila</h2>\n<p>O problema da mochila mais conhecido como knapsack é um problema clássico de otimização combinatória.</p>\n<p>O problema consiste em colocar o maior valor possível de itens em uma mochila com certa capacidade de peso. A mochila tem uma capacidade definida de peso. Os itens um peso e um valor. A objetivo é ter o maior valor possível dentro da mochila, ou seja, maximizar o valor.</p>\n<p>Esse problema aparece em diversas áreas como a logística, computação e investimentos.</p>\n<pre><code class=\"language-python\">import cvxpy as cp\nimport numpy as np\n# Dados de entrada do problema\nValores = np.array([10,13,1,100,45,13,156,76,4,59,97,99])\nPesos = np.array([50,55,10,5,1,98,34,3,9,3,7,19])\nCapacidade_Mochila = 100<br>\n# Variaveis de decisão<br>\n# Cada Item Xi terá valor 1 se estiver na mochila ou 0 se estiver fora\n# cp.Variable cria uma variável no CVX ( não confunda cp com np ) do tipo boolean do tamanho da quantidade de itens\n<br>Xi = cp.Variable((Valores.size), boolean = True)\n<br># Constraints do problema<br>\n# A soma total dos pesos dos itens escolhidos por Xi devem ser igual ou menor que a capacidade da mochila                \n<br>constraints = [ Xi @ Pesos &lt;= Capacidade_Mochila ]\n# Tambem pode ser escrito com o mesmo resultado como:\n#constraints = [ cp.sum( cp.multiply (Xi, Pesos ) ) &lt;= Capacidade_Mochila ]\n<br># O Objetivo do problema\n# é maximizar os valores na mochila<br>\nobjective = cp.Maximize( Xi @ Valores )\n<br># finalmente chamamos o solver com verbose para acompanhar \n# o progresso e a execução máxima de 1hr<br>\nprob = cp.Problem(objective, constraints)              \nprob.solve(solver=cp.CBC,verbose=True, maximumSeconds = 1 * 60 * 60)         \nprint(\"Status          : \", prob.status)\nprint(\"Valor encontrado: \", prob.value)\nprint(\"Valor de Xi     : \", Xi.value)\n    </code></pre>\n<p>O problema da mochila tem muitas aplicações práticas principalmente na logística. Imagine uma transportadora que precisa distribuir seus pacotes utilizando vans e caminhões. Cada pacote tem peso, tamanho, localidade, tempo de espera e valor. Um programa de otimização pode ajudar no preenchimento dos caminhões e em aplicações profissionais traçar a rota de distribuição de cada veículo.</p>\n<p>Problemas de otimização não acham o melhor valor, porque em geral é uma tarefa impossível (o mais correto seria improvável) de acha-lo devido a explosão combinatória. Por isso são chamados 'otimizadores' porque eles buscam a melhor solução possível, ou seja, uma solução ótima.</p>",
            "image": "https://fabiovila.github.io/media/posts/1/Screenshot-from-2021-05-15-17-39-07-2.png",
            "author": {
                "name": "Fabio"
            },
            "tags": [
                   "python",
                   "otimização",
                   "cvxpy"
            ],
            "date_published": "2020-07-26T15:35:10-03:00",
            "date_modified": "2021-06-02T13:47:21-03:00"
        }
    ]
}

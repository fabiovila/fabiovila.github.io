<!DOCTYPE html><html lang="pt-br"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="stylesheet" href="https://fabiovila.github.io/assets/css/high/github.css?v=754087c48785d8bc80b61b25cfa9f397"><script src="https://fabiovila.github.io/assets/js/highlight.min.js?v=794898ca191671a50f3d9908f4fa4815"></script><title>Rede neural em python numpy para iris dataset - Fabio</title><meta name="description" content="O entendimento de como funciona o treinamento das redes neurais é um&hellip;"><meta name="generator" content="Publii Open-Source CMS for Static Site"><link rel="canonical" href="https://fabiovila.github.io/rede-neural-em-python-numpy-para-iris-dataset.html"><link rel="alternate" type="application/atom+xml" href="https://fabiovila.github.io/feed.xml"><link rel="alternate" type="application/json" href="https://fabiovila.github.io/feed.json"><meta property="og:title" content="Rede neural em python numpy para iris dataset"><meta property="og:image" content="https://fabiovila.github.io/media/posts/6/Captura-de-tela-de-2021-06-02-14-23-17.png"><meta property="og:site_name" content="Fabio"><meta property="og:description" content="O entendimento de como funciona o treinamento das redes neurais é um&hellip;"><meta property="og:url" content="https://fabiovila.github.io/rede-neural-em-python-numpy-para-iris-dataset.html"><meta property="og:type" content="article"><style>:root{--body-font:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen,Ubuntu,Cantarell,"Fira Sans","Droid Sans","Helvetica Neue",Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol";--heading-font:var(--body-font);--logo-font:var(--body-font);--menu-font:var(--body-font)}</style><link rel="stylesheet" href="https://fabiovila.github.io/assets/css/style.css?v=769d7954b2b61cff57f960f9c5e4e9fd"><script type="application/ld+json">{"@context":"http://schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"https://fabiovila.github.io/rede-neural-em-python-numpy-para-iris-dataset.html"},"headline":"Rede neural em python numpy para iris dataset","datePublished":"2021-06-02T11:41","dateModified":"2021-06-02T14:23","image":{"@type":"ImageObject","url":"https://fabiovila.github.io/media/posts/6/Captura-de-tela-de-2021-06-02-14-23-17.png","height":215,"width":639},"description":"O entendimento de como funciona o treinamento das redes neurais é um&hellip;","author":{"@type":"Person","name":"Fabio"},"publisher":{"@type":"Organization","name":"Fabio"}}</script><script>MathJax = {
  tex: {
    inlineMath: [['$', '$']]
  }
};</script><script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script><script>hljs.highlightAll();</script></head><body><div class="container"><header class="header"><a href="https://fabiovila.github.io/" class="logo">Fabio</a></header><main><article class="post post--featured wrapper"><header class="hero"><p class="post__meta">By <a href="https://fabiovila.github.io/authors/fabio/" rel="author" title="Fabio">Fabio</a> Published on <time datetime="2021-06-02T11:41">junho 2, 2021</time></p><h1 class="post__title">Rede neural em python numpy para iris dataset</h1></header><figure class="post__featured-image post__image--wide"><img src="https://fabiovila.github.io/media/posts/6/Captura-de-tela-de-2021-06-02-14-23-17.png" srcset="https://fabiovila.github.io/media/posts/6/responsive/Captura-de-tela-de-2021-06-02-14-23-17-xs.png 300w, https://fabiovila.github.io/media/posts/6/responsive/Captura-de-tela-de-2021-06-02-14-23-17-sm.png 480w, https://fabiovila.github.io/media/posts/6/responsive/Captura-de-tela-de-2021-06-02-14-23-17-md.png 768w, https://fabiovila.github.io/media/posts/6/responsive/Captura-de-tela-de-2021-06-02-14-23-17-lg.png 1024w, https://fabiovila.github.io/media/posts/6/responsive/Captura-de-tela-de-2021-06-02-14-23-17-xl.png 1360w, https://fabiovila.github.io/media/posts/6/responsive/Captura-de-tela-de-2021-06-02-14-23-17-2xl.png 1600w, https://fabiovila.github.io/media/posts/6/responsive/Captura-de-tela-de-2021-06-02-14-23-17-sm2.png 375w" sizes="(max-width: 1600px) 100vw, 1600px" loading="eager" height="215" width="639" alt=""></figure><div class="post__entry"><p>O entendimento de como funciona o treinamento das redes neurais é um processo difícil por envolver conhecimentos de diversas áreas e matemática de nível superior. E mesmo para quem tem cálculo 1 e 2 quando se depara com a <em>derivação parcial do erro com base nos pesos</em> o entendimento não é trivial.</p><p>Ainda ficarei devendo essa explicação completa, mas enquanto isso segue este programa que fiz para python/numpy para treinar o dataset Iris usando duas camadas de redes neurais ativadas por sigmoide e treinadas usando retro-propagação com AdaGrad.</p><p>Sem o AdaGrad o treinamento se torna instável e pode ficar preso em um minimo local e nunca mais sair.</p><p>A convergência do Erro vai depender de cada execução devido a inicialização aleatória dos pesos, pode acontecer até mesmo de ainda sim ficar preso em um minimo local e não sair mais. Basta executar novamente que novos pesos aleatórios são inicializados.</p><p><a href="https://fabiovila.github.io/iris.data.csv" target="_blank" rel="noopener noreferrer" download>Link para download do iris dataset.</a></p><pre><code class="language-python">
import numpy as np

# Ativação sigmoid
def sig(n):
    return 1 / ( 1 + np.exp(-n))

# Derivada da sigmoid
# Muitos empacam aqui porque envolve cálculo 1 e 2 que só se aprende na faculdade
def dsig(n):
    return n * ( 1 - n)


if __name__ == '__main__':
    np.set_printoptions(precision=2 , suppress=True)

    # o iris.data.csv está organizado da seguinte forma:
    # 5.1,3.5,1.4,0.2,Iris-setosa
    # 4.9,3.0,1.4,0.2,Iris-setosa
    # 4.7,3.2,1.3,0.2,Iris-setosa
    #

    # carrega as quatro primeiras colunas que são os valores coletados na pesquisa
    X       = np.loadtxt('iris.data.csv', delimiter=',', usecols=[0,1,2,3])
    # carrega a última coluna contendo a string que define a categoria
    labels  = np.loadtxt('iris.data.csv', delimiter=',', dtype=str, usecols=[4])
    # Transforma as strings em valores númericos únicos
    l, Yu   = np.unique(labels, return_inverse=True)
    # e finalmente indexa cada valor numerico em um vetor 3 (ou matriz 1x3) 
    Y       = np.array([[0.0,0.0,1.0],[0.0,1.0,0.0],[1.0,0.0,0.0]])[Yu]
    
    r = np.random.randint(0,len(X),size=5)
    for rr in r:
        print ("X:" + str(X[rr]) + " Yu: " + str(Yu[rr]) + " Y: " + str(Y[rr]) + " Label: " + str(labels[rr]) )
    
    # logo os dados serão apresentados da seguinte forma para a rede neural
    # [5.1,3.5,1.4,0.2] - [1.0,0.0,0.0]


    # Dados armazenados, hora de montar a rede neural

    Wx = np.random.uniform(-5.0,5.0, size = (4,8))
    Bx = np.zeros((1,8))

    Wy = np.random.uniform(-5.0,5.0, size = (8,3))
    By = np.zeros((1,3))

    AWx = np.zeros((4,8))
    ABx = np.zeros((1,8))

    AWy = np.zeros((8,3))
    ABy = np.zeros((1,3))

    # faz uma breve previsão com a rede destreinada para observar os cálculos. O Forward
    ox =  sig(X[0] @ Wx + Bx)  # multiplicação de matrizes de X[0] com Wx e soma Bx o resultado é uma matrix e 1 linha e 8 colunas
    oy =  sig(ox @ Wy + By) 
    print(ox , oy)

    #let's cooking! vamos treinar a rede!
    lrate = 0.35
    for epoch in range(10000):
        # gera uma sequencia aleatória para ser usada como indice no próximo for
        # dessa forma os dados serão apresentados a rede de forma aleatória do que na sequência natural do arquivo
        Xr = np.random.permutation(len(X))
        et = 0  # erro total
        #lrate = lrate * 0.9999
        for ite in Xr:
            Xi = X[ite]
            Yi = Y[ite]



            ## o forward

            ox =  sig(Xi @ Wx + Bx)  # multiplicação de matrizes de X[0] com Wx e soma Bx o resultado é uma matrix e 1 linha e 8 colunas
            oy =  sig(ox @ Wy + By)


            ## o backward

            # o erro dessa interação
            e = oy - Yi 
            # a soma dos erros de todas a interações
            et += (e*e).sum()

            b = e * dsig(oy)
            delta = np.outer(ox,b)

            AWy += np.multiply(delta,delta)
            ABy += b*b

            Wy -= lrate * delta / np.sqrt(AWy + 1e-6)
            By -= lrate * b  / np.sqrt(ABy+1e-6)



            # propaga o erro para a camada x
            ex = e @ Wy.T

            # e finalmente atualiza a primeira camada
            b = ex * dsig(ox)
            delta = np.outer(Xi,b)

            AWx += np.multiply(delta,delta)
            ABx += b*b

            Wx -= lrate * delta / np.sqrt(AWx+1e-6)
            Bx -= lrate * b  / np.sqrt(ABx+1e-6)



        print ("Erro: %4.4f Learning Rate: %4.4f"%(et,lrate))
        #input()
            

    for n,xx in enumerate(X):
        ox =  sig(xx @ Wx + Bx)  
        oy =  sig(ox @ Wy + By)
        print ("X:" + str(xx) + " Y: " + str(Y[n]) + " Output: " + str(oy) )</code>  </pre></div><footer class="post__footer"><div class="post__last-updated">This article was updated on junho 2, 2021</div><div class="post__footer__col"><ul class="post__tag"><li><a href="https://fabiovila.github.io/machine-learning/">machine-learning</a></li><li><a href="https://fabiovila.github.io/numpy/">numpy</a></li><li><a href="https://fabiovila.github.io/python/">python</a></li><li><a href="https://fabiovila.github.io/redes-neurais/">redes-neurais</a></li></ul><div class="post__share"><a href="https://api.whatsapp.com/send?text=Rede%20neural%20em%20python%20numpy%20para%20iris%20dataset https%3A%2F%2Ffabiovila.github.io%2Frede-neural-em-python-numpy-para-iris-dataset.html" class="js-share whatsapp" aria-label="Share with Whats App" rel="nofollow noopener noreferrer"><svg class="icon"><use xlink:href="https://fabiovila.github.io/assets/svg/svg-map.svg#whatsapp"/></svg></a></div></div><nav class="post__nav"><div class="post__nav__prev">Previous Post<h5><a href="https://fabiovila.github.io/fazendo-um-cardapio-de-cafe-da-manha-com-calorias-e-baixo-custo-no-or-tools.html" class="inverse" rel="prev">Fazendo uma dieta de café da manhã de baixo custo no OR-TOOLs</a></h5></div><div class="post__nav__next">Next Post<h5><a href="https://fabiovila.github.io/usando-raspberry-pi-como-servidor-syslog-remoto-para-roteador-claronet.html" class="inverse" rel="next">Usando Raspberry Pi como servidor syslog remoto para roteador Claro/NET</a></h5></div></nav><div class="post__bio"><div><h3><a href="https://fabiovila.github.io/authors/fabio/" class="inverse" title="Fabio">Fabio</a></h3></div></div><div class="post__related"><h3 class="u-h5">Related posts</h3><div class="post__related__wrap"><figure><figcaption><h4><a href="https://fabiovila.github.io/usando-raspberry-pi-como-servidor-syslog-remoto-para-roteador-claronet.html" class="inverse">Usando Raspberry Pi como servidor syslog remoto para roteador Claro/NET</a></h4><time datetime="2021-07-09T20:56">julho 9, 2021</time></figcaption></figure><figure><a href="https://fabiovila.github.io/o-cvxpy-para-o-problema-de-mochila-knapsack.html"><img src="https://fabiovila.github.io/media/posts/1/responsive/Screenshot-from-2021-05-15-17-39-07-2-xs.png" loading="lazy" alt=""></a><figcaption><h4><a href="https://fabiovila.github.io/o-cvxpy-para-o-problema-de-mochila-knapsack.html" class="inverse">O CVXPY para o problema de mochila (knapsack)</a></h4><time datetime="2020-07-26T15:35">julho 26, 2020</time></figcaption></figure></div></div></footer></article></main><footer class="footer"><div class="footer__copyright">Powered by <a href="https://getpublii.com" target="_blank" rel="nofollow noopener">Publii</a></div></footer></div><script defer="defer" src="https://fabiovila.github.io/assets/js/scripts.min.js?v=c3bbc0611ea6a5405014eaca34fe1814"></script><script>window.publiiThemeMenuConfig={mobileMenuMode:'sidebar',animationSpeed:300,submenuWidth: 'auto',doubleClickTime:500,mobileMenuExpandableSubmenus:true,relatedContainerForOverlayMenuSelector:'.navbar'};</script><script>/*<![CDATA[*/var images=document.querySelectorAll("img[loading]");for(var i=0;i<images.length;i++){if(images[i].complete){images[i].classList.add("is-loaded")}else{images[i].addEventListener("load",function(){this.classList.add("is-loaded")},false)}};/*]]>*/</script></body></html>
<!DOCTYPE html><html lang="pt-br"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Rede neural em python numpy para iris dataset - Fabio</title><link rel="preconnect" href="https://fonts.gstatic.com"><link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:ital,wght@0,400;1,300&display=swap" rel="stylesheet"><link rel="stylesheet" href="https://fabiovila.github.io/assets/css/high/androidstudio.css?v=9e7d7647550e9ab1816737c96edda3ea"><script src="https://fabiovila.github.io/assets/js/highlight.min.js?v=794898ca191671a50f3d9908f4fa4815"></script><meta name="description" content="O entendimento de como funciona o treinamento das redes neurais é um processo difícil por envolver conhecimentos de diversas áreas e matemática de nível superior. E mesmo para quem tem cálculo 1 e 2 quando se depara com a derivação parcial do erro com base&hellip;"><meta name="generator" content="Publii Open-Source CMS for Static Site"><link rel="canonical" href="https://fabiovila.github.io/rede-neural-em-python-numpy-para-iris-dataset.html"><link rel="alternate" type="application/atom+xml" href="https://fabiovila.github.io/feed.xml"><link rel="alternate" type="application/json" href="https://fabiovila.github.io/feed.json"><meta property="og:title" content="Rede neural em python numpy para iris dataset"><meta property="og:site_name" content="Fabio"><meta property="og:description" content="O entendimento de como funciona o treinamento das redes neurais é um processo difícil por envolver conhecimentos de diversas áreas e matemática de nível superior. E mesmo para quem tem cálculo 1 e 2 quando se depara com a derivação parcial do erro com base&hellip;"><meta property="og:url" content="https://fabiovila.github.io/rede-neural-em-python-numpy-para-iris-dataset.html"><meta property="og:type" content="article"><link rel="preconnect" href="https://fonts.gstatic.com/" crossorigin><link href="https://fonts.googleapis.com/css?family=Rubik:400,700&amp;subset=latin-ext&amp;display=swap" rel="stylesheet"><style>:root{--body-font:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen,Ubuntu,Cantarell,"Fira Sans","Droid Sans","Helvetica Neue",Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol";--heading-font:'Rubik',sans-serif;--post-entry-font:var(--body-font);--logo-font:var(--body-font);--menu-font:var(--body-font)}</style><link rel="stylesheet" href="https://fabiovila.github.io/assets/css/style.css?v=85eaabd53117ce4fe7e057969866b6e7"><script type="application/ld+json">{"@context":"http://schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"https://fabiovila.github.io/rede-neural-em-python-numpy-para-iris-dataset.html"},"headline":"Rede neural em python numpy para iris dataset","datePublished":"2021-06-02T11:41","dateModified":"2021-06-02T14:17","description":"O entendimento de como funciona o treinamento das redes neurais é um processo difícil por envolver conhecimentos de diversas áreas e matemática de nível superior. E mesmo para quem tem cálculo 1 e 2 quando se depara com a derivação parcial do erro com base&hellip;","author":{"@type":"Person","name":"Fabio"},"publisher":{"@type":"Organization","name":"Fabio"}}</script><script>MathJax = {
  tex: {
    inlineMath: [['$', '$']]
  }
};</script><script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script></head><body><header class="topbar" id="js-header"><div class="topbar__inner"><a class="logo" href="https://fabiovila.github.io/">Fabio</a></div></header><div class="content"><div class="infobar"><div class="infobar__update">Last Updated: <time datetime="2021-06-02T14:20">junho 2, 2021</time></div><div class="infobar__search"><form action="https://fabiovila.github.io/search.html"><input type="search" name="q" placeholder="search..." aria-label="Search input"> <button type="submit" aria-label="Submit"><svg role="presentation" focusable="false" width="15px" height="14px"><use xlink:href="https://fabiovila.github.io/assets/svg/svg-map.svg#search"/></svg></button></form></div></div><main class="main"><article class="post"><header class="u-header post__header"><h1>Rede neural em python numpy para iris dataset</h1><div class="u-header__meta u-small"><div><a href="https://fabiovila.github.io/authors/fabio/" title="Fabio">Fabio</a> <time datetime="2021-06-02T11:41">junho 2, 2021 </time><a href="https://fabiovila.github.io/machine-learning/" class="u-tag u-tag--1">machine-learning</a></div></div></header><div class="post__entry u-inner"><p>O entendimento de como funciona o treinamento das redes neurais é um processo difícil por envolver conhecimentos de diversas áreas e matemática de nível superior. E mesmo para quem tem cálculo 1 e 2 quando se depara com a <em>derivação parcial do erro com base nos pesos</em> o entendimento não é trivial.</p><p>Ainda ficarei devendo essa explicação completa, mas enquanto isso segue este programa que fiz para python/numpy para treinar o dataset Iris usando duas camadas de redes neurais ativadas por sigmoide e treinadas usando retro-propagação com AdaGrad.</p><p>Sem o AdaGrad o treinamento se torna instável e pode ficar preso em um minimo local e nunca mais sair.</p><p>A convergência do Erro vai depender de cada execução devido a inicialização aleatória dos pesos, pode acontecer até mesmo de ainda sim ficar preso em um minimo local e não sair mais. Basta executar novamente que novos pesos aleatórios são inicializados.</p><p><a href="https://fabiovila.github.io/iris.data.csv" target="_blank" rel="noopener noreferrer" download>Link para download do iris dataset.</a></p><pre><code class="language-python">
import numpy as np

# Ativação sigmoid
def sig(n):
    return 1 / ( 1 + np.exp(-n))

# Derivada da sigmoid
# Muitos empacam aqui porque envolve cálculo 1 e 2 que só se aprende na faculdade
def dsig(n):
    return n * ( 1 - n)


if __name__ == '__main__':
    np.set_printoptions(precision=2 , suppress=True)

    # o iris.data.csv está organizado da seguinte forma:
    # 5.1,3.5,1.4,0.2,Iris-setosa
    # 4.9,3.0,1.4,0.2,Iris-setosa
    # 4.7,3.2,1.3,0.2,Iris-setosa
    #

    # carrega as quatro primeiras colunas que são os valores coletados na pesquisa
    X       = np.loadtxt('iris.data.csv', delimiter=',', usecols=[0,1,2,3])
    # carrega a última coluna contendo a string que define a categoria
    labels  = np.loadtxt('iris.data.csv', delimiter=',', dtype=str, usecols=[4])
    # Transforma as strings em valores númericos únicos
    l, Yu   = np.unique(labels, return_inverse=True)
    # e finalmente indexa cada valor numerico em um vetor 3 (ou matriz 1x3) 
    Y       = np.array([[0.0,0.0,1.0],[0.0,1.0,0.0],[1.0,0.0,0.0]])[Yu]
    
    r = np.random.randint(0,len(X),size=5)
    for rr in r:
        print ("X:" + str(X[rr]) + " Yu: " + str(Yu[rr]) + " Y: " + str(Y[rr]) + " Label: " + str(labels[rr]) )
    
    # logo os dados serão apresentados da seguinte forma para a rede neural
    # [5.1,3.5,1.4,0.2] - [1.0,0.0,0.0]


    # Dados armazenados, hora de montar a rede neural

    Wx = np.random.uniform(-5.0,5.0, size = (4,8))
    Bx = np.zeros((1,8))

    Wy = np.random.uniform(-5.0,5.0, size = (8,3))
    By = np.zeros((1,3))

    AWx = np.zeros((4,8))
    ABx = np.zeros((1,8))

    AWy = np.zeros((8,3))
    ABy = np.zeros((1,3))

    # faz uma breve previsão com a rede destreinada para observar os cálculos. O Forward
    ox =  sig(X[0] @ Wx + Bx)  # multiplicação de matrizes de X[0] com Wx e soma Bx o resultado é uma matrix e 1 linha e 8 colunas
    oy =  sig(ox @ Wy + By) 
    print(ox , oy)

    #let's cooking! vamos treinar a rede!
    lrate = 0.35
    for epoch in range(10000):
        # gera uma sequencia aleatória para ser usada como indice no próximo for
        # dessa forma os dados serão apresentados a rede de forma aleatória do que na sequência natural do arquivo
        Xr = np.random.permutation(len(X))
        et = 0  # erro total
        #lrate = lrate * 0.9999
        for ite in Xr:
            Xi = X[ite]
            Yi = Y[ite]



            ## o forward

            ox =  sig(Xi @ Wx + Bx)  # multiplicação de matrizes de X[0] com Wx e soma Bx o resultado é uma matrix e 1 linha e 8 colunas
            oy =  sig(ox @ Wy + By)


            ## o backward

            # o erro dessa interação
            e = oy - Yi 
            # a soma dos erros de todas a interações
            et += (e*e).sum()

            b = e * dsig(oy)
            delta = np.outer(ox,b)

            AWy += np.multiply(delta,delta)
            ABy += b*b

            Wy -= lrate * delta / np.sqrt(AWy + 1e-6)
            By -= lrate * b  / np.sqrt(ABy+1e-6)



            # propaga o erro para a camada x
            ex = e @ Wy.T

            # e finalmente atualiza a primeira camada
            b = ex * dsig(ox)
            delta = np.outer(Xi,b)

            AWx += np.multiply(delta,delta)
            ABx += b*b

            Wx -= lrate * delta / np.sqrt(AWx+1e-6)
            Bx -= lrate * b  / np.sqrt(ABx+1e-6)



        print ("Erro: %4.4f Learning Rate: %4.4f"%(et,lrate))
        #input()
            

    for n,xx in enumerate(X):
        ox =  sig(xx @ Wx + Bx)  
        oy =  sig(ox @ Wy + By)
        print ("X:" + str(xx) + " Y: " + str(Y[n]) + " Output: " + str(oy) )</code>  </pre></div><aside class="post__aside"><div class="post__last-updated u-small">This article was updated on junho 2, 2021</div><div class="post__share"><a href="https://www.facebook.com/sharer/sharer.php?u=https%3A%2F%2Ffabiovila.github.io%2Frede-neural-em-python-numpy-para-iris-dataset.html" class="js-share facebook" title="Share with Facebook" rel="nofollow noopener noreferrer" aria-label="Share with Facebook"><svg class="u-icon"><use xlink:href="https://fabiovila.github.io/assets/svg/svg-map.svg#facebook"/></svg> </a><a href="https://wa.me/?text=Rede%20neural%20em%20python%20numpy%20para%20iris%20dataset https%3A%2F%2Ffabiovila.github.io%2Frede-neural-em-python-numpy-para-iris-dataset.html" class="js-share whatsapp" rel="nofollow noopener noreferrer" title="Share with WhatsApp" aria-label="Share with WhatsApp"><svg class="u-icon"><use xlink:href="https://fabiovila.github.io/assets/svg/svg-map.svg#whatsapp"/></svg> </a><a href="http://www.linkedin.com/shareArticle?url=https%3A%2F%2Ffabiovila.github.io%2Frede-neural-em-python-numpy-para-iris-dataset.html&amp;title=Rede%20neural%20em%20python%20numpy%20para%20iris%20dataset" class="js-share linkedin" title="Share with LinkedIn" rel="nofollow noopener noreferrer" aria-label="Share with LinkedIn"><svg class="u-icon"><use xlink:href="https://fabiovila.github.io/assets/svg/svg-map.svg#linkedin"/></svg></a></div></aside><footer class="post__footer"><div class="post__bio box"><div><h4 class="h6"><a href="https://fabiovila.github.io/authors/fabio/" title="Fabio">Fabio</a></h4></div></div><nav class="post__nav box"><div class="post__nav__prev"><a href="https://fabiovila.github.io/fazendo-um-cardapio-de-cafe-da-manha-com-calorias-e-baixo-custo-no-or-tools.html" class="post__nav__link" rel="prev"><img src="https://fabiovila.github.io/media/posts/2/responsive/bread-18987_640-xs.jpg" loading="lazy" alt=""><div class="u-small">Previous Post<h5>Fazendo uma dieta de café da manhã de baixo custo no OR-TOOLs</h5></div></a></div></nav><div class="post__related box"><h3 class="box__title">Related posts</h3><div class="post__related-wrap"><figure class="post__related-item"><a href="https://fabiovila.github.io/o-cvxpy-para-o-problema-de-mochila-knapsack.html" class="c-card__image"><img src="https://fabiovila.github.io/media/posts/1/responsive/Screenshot-from-2021-05-15-17-39-07-2-xs.png" loading="lazy" height="381" width="811" alt=""></a><figcaption><h4 class="post__related-title"><a href="https://fabiovila.github.io/o-cvxpy-para-o-problema-de-mochila-knapsack.html" class="inverse">O CVXPY para o problema de mochila (knapsack)</a></h4><time datetime="2020-07-26T15:35" class="u-small">julho 26, 2020</time></figcaption></figure></div></div></footer></article></main><div class="sidebar"><section class="box featured"><h3 class="box__title">Featured</h3><ul class="featured__container"><li class="featured__item"><div><a href="https://fabiovila.github.io/rede-neural-em-python-numpy-para-iris-dataset.html" class="featured__title">Rede neural em python numpy para iris dataset</a> <time class="u-small" datetime="2021-06-02T11:41">junho 2, 2021</time></div></li></ul></section><section class="box authors"><h3 class="box__title">Authors</h3><ul class="authors__cotainer"><li class="authors__item"><div><a href="https://fabiovila.github.io/authors/fabio/" class="authors__title">Fabio</a> <span class="u-small">Post: 3</span></div></li></ul></section><section class="box"><h3 class="box__title">Tags</h3><ul class="tags"><li><a href="https://fabiovila.github.io/cvxpy/">cvxpy</a> <span class="u-small">(2)</span></li><li><a href="https://fabiovila.github.io/machine-learning/">machine-learning</a> <span class="u-small">(1)</span></li><li><a href="https://fabiovila.github.io/numpy/">numpy</a> <span class="u-small">(1)</span></li><li><a href="https://fabiovila.github.io/otimizacao/">otimização</a> <span class="u-small">(2)</span></li><li><a href="https://fabiovila.github.io/python/">python</a> <span class="u-small">(3)</span></li></ul></section></div><footer class="footer"><a class="footer__logo" href="https://fabiovila.github.io/">Fabio</a><nav><ul class="footer__nav"></ul></nav><div class="footer__copyright"><p>Powered by <a href="https://getpublii.com" target="_blank" rel="nofollow noopener">Publii</a></p></div></footer></div><script>window.publiiThemeMenuConfig = {    
        mobileMenuMode: 'sidebar',
        animationSpeed: 300,
        submenuWidth: 'auto',
        doubleClickTime: 500,
        mobileMenuExpandableSubmenus: true, 
        relatedContainerForOverlayMenuSelector: '.navbar',
   };</script><script defer="defer" src="https://fabiovila.github.io/assets/js/prism.js?v=69a32fbf58ef6b3bd9ee36d8cdf634d4"></script><script defer="defer" src="https://fabiovila.github.io/assets/js/scripts.min.js?v=3dc768003cc6d66c9e7bf0904e71d3e8"></script><script>var images = document.querySelectorAll('img[loading]');

      for (var i = 0; i < images.length; i++) {
         if (images[i].complete) {
               images[i].classList.add('is-loaded');
         } else {
               images[i].addEventListener('load', function () {
                  this.classList.add('is-loaded');
               }, false);
         }
      }</script><script>hljs.highlightAll();</script></body></html>
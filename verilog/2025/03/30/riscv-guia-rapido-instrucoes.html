<!DOCTYPE html>
<html lang="pt-BR">
    <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- Primary Meta Tags -->
    <title>Super guia ilustrado das instruções RISC-V RVI32 - Verilog</title>
    <meta name="title" content="Super guia ilustrado das instruções RISC-V RVI32 - Verilog" />
    <meta name="description" content="" />
    

    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website" />
    <meta property="og:url" content="/verilog/2025/03/30/riscv-guia-rapido-instrucoes.html" />
    <meta property="og:title" content="Super guia ilustrado das instruções RISC-V RVI32 - Verilog" />
    <meta property="og:description" content="Resumo das instruções RISCV"  />
    <meta property="og:image" content="/assets/imgs/uma CPU.png" />

    <!-- Twitter -->
    <meta property="twitter:card" content="summary_large_image" />
    <meta property="twitter:url" content="/verilog/2025/03/30/riscv-guia-rapido-instrucoes.html" />
    <meta property="twitter:title" content="Super guia ilustrado das instruções RISC-V RVI32 - Verilog"  />
    <meta property="twitter:description" content="Resumo das instruções RISCV" />
    <meta property="twitter:image" content="/assets/imgs/uma CPU.png"/>

    <!-- Meta Tags Generated with https://metatags.io -->
    <link rel="preload"  href='/assets/css/style.css' as="style" type="text/css">
    <link rel="stylesheet"  href='/assets/css/style.css'>
    <link rel="stylesheet"  href='/assets/css/github.css'>
    <script rel="preload" src="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.6.0/js/all.min.js" integrity="sha512-6sSYJqDreZRZGkJ3b+YfdhB3MzmuP9R7X1QZ6g5aIXhRvR1Y/N/P47jmnkENm7YL3oqsmI6AK+V6AD99uWDnIw==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script>
        var $ = function(id){return document.getElementById(id)};
        MathJax = {
          jax: ["input/TeX","output/HTML-CSS"],
          chtml: { displayAlign: 'left'      },
          tex: {
            inlineMath: [['$', '$']],
            displayMath:[['$$', '$$'], ['\\[', '\\]']]
          }
          };
    </script>
        <script id="MathJax-script" async
          src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
        </script>
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css">
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>      
        <script>hljs.highlightAll();</script>
         <!-- Global site tag (gtag.js) - Google Analytics -->
        <script async src="https://www.googletagmanager.com/gtag/js?id=G-PY9DT1RWSW"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-PY9DT1RWSW');
        </script>
</head>

    <body>
    <nav class="navbar">
    <div class="container">
      <div class="navbar-brand">
        <a class="navbar-item"  href="/">
          <h1 class="has-text-weight-bold is-capitalized" >Fabio Vila</h1>
        </a>
        <span class="navbar-burger" data-target="navbarMenuHeroA">
          <span></span>
          <span></span>
          <span></span>
        </span>
      </div>
      <div id="navbarMenuHeroA" class="navbar-menu">
        <div class="navbar-end">
          <a href="/" class="navbar-item">
            Home
          </a>
          <a href="https://vilaboard.com" class="navbar-item">
            Vilaboard
          </a>
        </div>
      </div>
    </div>
  </nav>


<section class="section ">
<div class="columns is-centered">
<div class="column is-9 ">
<div class="content is-fluid">

  <header class="mb-5">
    <h1 class="title is-warning">Super guia ilustrado das instruções RISC-V RVI32 - Verilog</h1>
    <h4 class="subtitle has-text-weight-light is-family-sans-serif"></h4>
    
    <h4 class="subtitle has-text-weight-light is-family-sans-serif">Resumo das instruções RISCV</h4>
    
    <hr class="m-1"/>
    <small class="pl-2 has-text-dark-grey" ><span class="icon "><i class="fa fa-user "></i></span>
      
      Fabio
         
    <span class="icon"><i class="fa fa-calendar"></i></span>  
     30 Mar 2025
     <span class="icon"><i class="fa fa-bars"></i></span>
    Verilog
    <span class="icon"><i class="fa fa-tag"></i></span>  
    Verilog e riscv
    </small>
    <hr class="mt-1 mb-5"/>
    
    <div class="h-400">
        
        <img class="image" style="width:100%" src="/assets/imgs/uma CPU.png"/>
        
    </div>
    


  </header>

  <article class="mt-5">
    <p>Cada vez mais processadores e microcontroladores RISC-V estão surgindo no mercado como alternativa ao ARM e MIPS. De livre implementação, sem Royalties ou custos o conjunto de instruções RISC-V tem ganhado atenção. O termo RISC-V em sí não se refere a uma CPU ou Empresa, mas ao <strong>Conjunto de Instruções aberto e de livre implementação administrado pela RISC-V International</strong>. RISC-V International é uma organização sem fins lucrativos que gerencia a arquitetura aberta RISC-V e suas especificações. Com mais de 4.500 membros em 70 países, promove inovação acessível sem royalties. Fundada como RISC-V Foundation em 2015 e realocada para a Suíça em 2020, garante continuidade e colaboração global.</p>

<p>A arquitetura permite liberdade de design, sendo usada tanto em projetos abertos quanto proprietários. O conjunto de instruções RISC-V foi iniciado em 2010 por Krste Asanović, Yunsup Lee e Andrew Waterman no Par Lab da UC Berkeley, liderado por David Patterson. O Par Lab, financiado por Intel e Microsoft, visava avanços em computação paralela entre 2008 e 2013. O projeto RISC-V e a linguagem Chisel foram desenvolvidos como open source sob a licença BSD. Parte do financiamento veio da DARPA para implementação de processadores, mas não para a ISA RISC-V.</p>

<p>Na prática isso quer dizer que as instruções são abertas e livres para implementação, porém <strong>não há nenhuma CPU com a marca RISC-V</strong>, as CPUs disponíveis no mercado com <strong>as instruções e extensões RISC-V</strong> são CPUs de empresas como SiFive, GigaDevices, Microchip, entre outras com projeto fechado e proprietário, e não deixariam de ser, visto que a fabricação fisica de uma CPU envolve projeto e processos fabris em microeletrônica protegidos e caros.</p>

<p>O interesse no RISC-V aliado a sua liberdade de uso faz com que algumas pessoas implementem sua própria CPU RISC-V, seja com emuladores, em Verilog ou VHDL simulando em software ou sintetizados para alguma FPGA. De fato pode-se inclusive comercializar uma implementação em FPGA, ao contrário do conjunto de instruções ARM.</p>

<p>Como fazer uma CPU envolve processos complexos, como conhecer uma linguagem de descrição de hardware (Verilog ou VHDL), conhecer arquitetura de CPUs, memória, barramento e eletrônica digital, este artigo foi feito para ajudar no entendimento da arquitetura RISC-V com ilustrações e trechos de códigos em Verilog e C. E espero que seja de grande ajuda!</p>

<div class="destaque amarelo br bl">
Escrever sua própria CPU é um exercício de gente grande! Extremamente útil na compreensão do funcionamento interno das CPUs e arquitetura de computadores.
</div>

<h3 id="instruções-base-rvi32">Instruções Base RVI32</h3>

<p>A especificação RISC-V divide-se em instruções Base e Extensões. Em 32 bits as instruções Base são conhecidas como RVI32, que contem instruções de Movimentação, Soma, Lógicas, Saltos e de Sistema (não-protegido). Elas são divididas em 6 grupos de codificação de imediatos chamados R, I, S, B, U e J cujos formatos são ilustrados abaixo:</p>

<p><img src="/assets/imgs/riscv/RISBUJ.svg" alt="" /></p>

<ul>
  <li><strong>opcode</strong> - 7 bits identificando cada grupo de instruções. <strong>opcode</strong> pode indicar um grupo de instruções ou uma instrução somente</li>
  <li><strong>rd</strong> - 5 bits identificando um dos 32 registradores de destino do resultado da instrução</li>
  <li><strong>rs1</strong> - 5 bits identificando um dos 32 registradores fonte (source) numero 1</li>
  <li><strong>rs2</strong> - 5 bits identificando um dos 32 registradores fonte (source) numero 2</li>
  <li><strong>funct3</strong> - 3 bits que junto de <strong>funct7</strong> identifica a instrução a ser executada do tipo determinado por <strong>opcode</strong></li>
  <li><strong>funct7</strong> - 7 bits que junto de <strong>funct3</strong> identifica a instrução a ser executada do tipo determinado por <strong>opcode</strong></li>
  <li><strong>imm[:] ou []</strong> - São os valores numéricos da instrução que serão usados em algum cálculo interno de deslocamento ou armazenamento.</li>
</ul>

<p>Como se pode observar as intruções são todas em 32 bits o que facilita no fetch e decodificação da instrução. Como toda arquitetura RISC pura, o campo rs1, rs2 indicam os registradores que contém os operandos das instruções e rd o destino do resultado; não há instruções que efetuam cálculos com operandos ou destinos direto na memória, esses valores devem antes ser carregados nos registradores rs1 ou rs2 e o resultado da operação será guardado em rd e quando então a instrução store poderá gravar o conteúdo de qualquer registrador na memória. Se fosse o caso de um processador CISC poderiamos ter instruções de outros tamanhos além dos 32 bits e imediatos que sirvam de endereços para execução da instrução direto na memória.</p>

<p>Agora exploraremos esses 6 tipos detalhadamente.</p>

<h3 id="tipo-r">Tipo R</h3>

<p>As instruções do tipo R são as mais fáceis de se entender e um ótimo ponto de partida. São denominadas R justamente por operarem em operandos contidos em registradores, que foram previamente carregados pelas instruções tipo I, U ou resultado de uma operação anterior tipo R.</p>

<p><img src="/assets/imgs/riscv/riscv-tipo-r.svg" alt="" /></p>

<p>Na ilustração acima ALU é a unidade aritmética que faz diversas operações como soma, diferença, xor, and entre outras. O campo <strong>opcode</strong> da instrução em RV32I com valor <code class="language-plaintext highlighter-rouge">0110011</code>identifica as instruções tipo R. Quem determinará qual operação a ALU efetuará será a combinação de <strong>funct7</strong> e <strong>funct3</strong> conforme tabela abaixo. <strong>rs1</strong> e <strong>rs2</strong> são o identificador de um dos 32 registradores que serão respectivamente o valor rs1 e rs2 da ALU e finalmente o resultado da operação aritmética será armazenado no registrador indexado por <strong>rd</strong>.</p>

<table>
  <thead>
    <tr>
      <th>funct7</th>
      <th>rs2</th>
      <th>rs1</th>
      <th>funct3</th>
      <th>rd</th>
      <th>op</th>
      <th>instrução</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>0000000</td>
      <td>rs2</td>
      <td>rs1</td>
      <td>000</td>
      <td>rd</td>
      <td>0110011</td>
      <td>ADD</td>
    </tr>
    <tr>
      <td>0100000</td>
      <td>rs2</td>
      <td>rs1</td>
      <td>000</td>
      <td>rd</td>
      <td>0110011</td>
      <td>SUB</td>
    </tr>
    <tr>
      <td>0000000</td>
      <td>rs2</td>
      <td>rs1</td>
      <td>001</td>
      <td>rd</td>
      <td>0110011</td>
      <td>SLL</td>
    </tr>
    <tr>
      <td>0000000</td>
      <td>rs2</td>
      <td>rs1</td>
      <td>010</td>
      <td>rd</td>
      <td>0110011</td>
      <td>SLT</td>
    </tr>
    <tr>
      <td>0000000</td>
      <td>rs2</td>
      <td>rs1</td>
      <td>011</td>
      <td>rd</td>
      <td>0110011</td>
      <td>SLTU</td>
    </tr>
    <tr>
      <td>0000000</td>
      <td>rs2</td>
      <td>rs1</td>
      <td>100</td>
      <td>rd</td>
      <td>0110011</td>
      <td>XOR</td>
    </tr>
    <tr>
      <td>0000000</td>
      <td>rs2</td>
      <td>rs1</td>
      <td>101</td>
      <td>rd</td>
      <td>0110011</td>
      <td>SRL</td>
    </tr>
    <tr>
      <td>0100000</td>
      <td>rs2</td>
      <td>rs1</td>
      <td>101</td>
      <td>rd</td>
      <td>0110011</td>
      <td>SRA</td>
    </tr>
    <tr>
      <td>0000000</td>
      <td>rs2</td>
      <td>rs1</td>
      <td>110</td>
      <td>rd</td>
      <td>0110011</td>
      <td>OR</td>
    </tr>
    <tr>
      <td>0000000</td>
      <td>rs2</td>
      <td>rs1</td>
      <td>111</td>
      <td>rd</td>
      <td>0110011</td>
      <td>AND</td>
    </tr>
  </tbody>
</table>

<p>Veja que <strong>funct7</strong> somente faz distinção das instruções ADD/SUB e SRL/SRA cujo <strong>funct3</strong> são iguais.</p>

<p>Para extrair esse valores em Verilog utilize o código abaixo:</p>

<pre><code class="language-Verilog">wire [6:0]  OPCODE          =   INS[6:0];
wire [2:0]  FUNCT3          =   INS[14:12];
wire [6:0]  FUNCT7          =   INS[31:25];
wire [4:0]  RS1_INDEX       =   INS[19:15];
wire [4:0]  RS2_INDEX       =   INS[24:20];
wire [4:0]  RD_INDEX        =   INS[11:7];
</code></pre>
<p>E no caso de uma emulador C/C++:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">opcode</span>      <span class="o">=</span> <span class="n">ins</span> <span class="o">&amp;</span> <span class="mi">127</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">funct3</span>      <span class="o">=</span> <span class="p">(</span><span class="n">ins</span> <span class="o">&amp;</span> <span class="mi">28672</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">12</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">funct7</span>      <span class="o">=</span> <span class="p">(</span><span class="n">ins</span> <span class="o">&amp;</span> <span class="mi">4261412864</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">25</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">rs1_index</span>   <span class="o">=</span> <span class="p">(</span><span class="n">ins</span> <span class="o">&amp;</span> <span class="mi">1015808</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">15</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">rs2_index</span>   <span class="o">=</span> <span class="p">(</span><span class="n">ins</span> <span class="o">&amp;</span> <span class="mi">32505856</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">20</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">rd_index</span>    <span class="o">=</span> <span class="p">(</span><span class="n">ins</span> <span class="o">&amp;</span> <span class="mi">3968</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">7</span><span class="p">;</span>  
</code></pre></div></div>

<p>Esses imediatos e indexadores serão utilizados em outras instruções sendo então reaproveitados nos outros tipos. Sendo essa uma das vantagens de um processador RISC moderno como o RISC-V, os imediatos tem posições fixas que facilitam a decodificação sem precisar de máquinas de estado (micro-código) e lógicas adicionais, o que torna o uso de portas lógicas o minimo possível no RISC-V, permitindo então, fazer vários processadores, chamados harts, em uma pastilha de silicio ou sintetizados em FPGA, ou seja, um multi-processador.</p>

<h3 id="tipo-i">Tipo I</h3>

<p>Instruções tipo I ou Immediato permitem carregar os registradores com valores através da ALU. Todas as instruções do tipo I fazem alguma operação aritmética no imediato da instrução, porém se o programador não quiser efetuar operação alguma no valor, basta somar com o registrador zero, e como toda soma de um número com zero é ele mesmo, então esse valor numérico imediato será armazenado no registrador sem alteração alguma. O x86 tem as instruções MOV, porém o RISC-V não tem uma instrução de carga explicita, somente aritméticas! Sim! Se você quer carregar um valor some ele com zero!</p>

<div class="destaque amarelo bl br">
Alguns acham estranho não ter uma instrução de carga explicita como é no x86 ou mesmo no ARM. No RISC-V não há instruções de Load ou Movimento, o mais próximo disso é a instrução tipo U que armazena o imediato nos 20 bits de cima de um registrador.
</div>

<p>As instruções tipo I apenas diferem das tipo R por não usarem <strong>rs2</strong> como operando, porém usam o valor imediato presente na instrução que deve ser extraido pelo decodificado de instruções.</p>

<p><img src="/assets/imgs/riscv/riscv-tipo-i.svg" alt="" /></p>

<p>Percebe-se na ilustração que a única diferença é a ausência de <strong>rs2</strong> que foi substituido pela palavra de 32 bits montada através dos bits <code class="language-plaintext highlighter-rouge">31:20</code> da instrução que foram extraídos e concatenados nos bits <code class="language-plaintext highlighter-rouge">12:0</code> da palavra de 32 bits.</p>

<p>O sinal de <code class="language-plaintext highlighter-rouge">imm[11:0]</code>, ou seja, o bit <code class="language-plaintext highlighter-rouge">imm[11]</code> é extendido para o restante dos 32 bits da palavra, na prática se copia esse bit aos 20 bits restantes da palavra. Algo fácil de se fazer em Verilog porém em software é custoso. 
Em seguida executa-se a operação da ALU com os operandos <code class="language-plaintext highlighter-rouge">imm_i</code> e <strong>rs1</strong> com destino em <strong>rd</strong>.</p>

<table>
  <thead>
    <tr>
      <th>imm[11:0]</th>
      <th>rs1</th>
      <th>funct3</th>
      <th>rd</th>
      <th>op</th>
      <th>instrução</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>xxxxxxxxxxxx</td>
      <td>rs1</td>
      <td>000</td>
      <td>rd</td>
      <td>0010011</td>
      <td>ADDI</td>
    </tr>
    <tr>
      <td>xxxxxxxxxxxx</td>
      <td>rs1</td>
      <td>010</td>
      <td>rd</td>
      <td>0010011</td>
      <td>SLTI</td>
    </tr>
    <tr>
      <td>xxxxxxxxxxxx</td>
      <td>rs1</td>
      <td>011</td>
      <td>rd</td>
      <td>0010011</td>
      <td>SLTIU</td>
    </tr>
    <tr>
      <td>xxxxxxxxxxxx</td>
      <td>rs1</td>
      <td>100</td>
      <td>rd</td>
      <td>0010011</td>
      <td>XORI</td>
    </tr>
    <tr>
      <td>xxxxxxxxxxxx</td>
      <td>rs1</td>
      <td>110</td>
      <td>rd</td>
      <td>0010011</td>
      <td>ORI</td>
    </tr>
    <tr>
      <td>xxxxxxxxxxxx</td>
      <td>rs1</td>
      <td>111</td>
      <td>rd</td>
      <td>0010011</td>
      <td>ANDI</td>
    </tr>
  </tbody>
</table>

<p>Para montar o <strong>Imediato</strong> segue código sugestivo em Verilog e C/C++:</p>

<pre><code class="language-Verilog">wire [31:0]  IMM_I             =   {{20{INS[31]}},INS[31:20]};
</code></pre>

<p>E no caso de uma emulador C/C++:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int32_t</span> <span class="n">imm_i</span>      <span class="o">=</span> <span class="p">(</span><span class="n">ins</span> <span class="o">&gt;&gt;</span> <span class="mi">20</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xfff</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="n">imm_i</span> <span class="o">&amp;</span> <span class="mh">0x800</span><span class="p">)</span>          <span class="c1">// se o bit 11 tá setado</span>
    <span class="n">imm_i</span> <span class="o">|=</span> <span class="mh">0xFFFFF000</span><span class="p">;</span>    <span class="c1">// preenche o restante com 1s</span>
</code></pre></div></div>

<p>Há outras formas em C/C++ de se fazer isso e é possível ainda otimizar utilizando instruções assembly que extraem bits com sinal extendido se houver na CPU que se escreve o emulador.</p>

<p>A instrução de salto incondicional JALR também utiliza o Tipo I de codificação de imediato, porém será explicada posteriormente.</p>

<h4 id="o-caso-slli-srli-e-srai">O caso SLLI, SRLI e SRAI</h4>

<p>As instruções de deslocamento a direita e a esquerda são do tipo I porém tem tratamento diferente. 
O <code class="language-plaintext highlighter-rouge">imm[11:0]</code> contém duas informações, o <strong>shamt</strong> que localiza-se no <code class="language-plaintext highlighter-rouge">imm[4:0]</code> contendo a quantidade de deslocamento que pode ser 0 a 31 e a distinção entre <code class="language-plaintext highlighter-rouge">SRLI</code> e <code class="language-plaintext highlighter-rouge">SRAI</code>. Lembre-se que não há sentido deslocar mais que 31 bits pois a palavra tem somente 32 bits, logo <strong>shamt</strong> tem tamanho de 5 bits.
Finalmente <code class="language-plaintext highlighter-rouge">imm[30]</code>diferencia <code class="language-plaintext highlighter-rouge">SRLI</code>de <code class="language-plaintext highlighter-rouge">SRAI</code> já que ambos têm o mesmo <strong>funct3</strong>.</p>

<table>
  <thead>
    <tr>
      <th> </th>
      <th>shamt</th>
      <th>rs1</th>
      <th>funct3</th>
      <th>rd</th>
      <th>op</th>
      <th>instrução</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>0000000</td>
      <td>xxxxx</td>
      <td>rs1</td>
      <td>001</td>
      <td>rd</td>
      <td>0010011</td>
      <td>SLLI</td>
    </tr>
    <tr>
      <td>0000000</td>
      <td>xxxxx</td>
      <td>rs1</td>
      <td>101</td>
      <td>rd</td>
      <td>0010011</td>
      <td>SRLI</td>
    </tr>
    <tr>
      <td>0100000</td>
      <td>xxxxx</td>
      <td>rs1</td>
      <td>101</td>
      <td>rd</td>
      <td>0010011</td>
      <td>SRAI</td>
    </tr>
  </tbody>
</table>

<p>A extração de <strong>shamt</strong> pode ser otimizada utilizando o mesmo código de <strong>rs2</strong> e o discriminador com o mesmo código <strong>funct7</strong>.</p>

<h3 id="load-e-store">Load e Store</h3>

<p>As instruções de movimento da memória para o registrador e do registrador para a memória, <strong>Load</strong> e <strong>Store</strong>, têm o endereço armazenado em um dos registradores, que será denominado <em>base</em>, com a adição do imediato, denominado <em>offset</em>, de 12 bits codificado na instrução, também com sinal extendido, o que permite, então, apontar o endereço para cima ou para baixo do endereço apontado pelo registrador <em>base</em>.</p>

<h4 id="load">Load</h4>

<p><strong>Load</strong> tem formato igual ao tipo I visto anteriormente. O imediato (<em>offset</em>) <code class="language-plaintext highlighter-rouge">imm[11:0]</code> é somado ao registrador <strong>rs1</strong> e o resultado é usado como endereço de leitura da memória para ser armazenado no registrador <strong>rd</strong>.</p>

<p><img src="/assets/imgs/riscv/riscv-load.svg" alt="" /></p>

<p><strong>funct3</strong> faz distinção de 5 tamanhos de leitura sendo eles bytes (8 bits) <strong>LB</strong> e <strong>LBU</strong>, half-words (16 bits) <strong>LH</strong> e <strong>LHU</strong> e words (32 bits) <strong>LW</strong> e se os tipos bytes e half-words fazem extensão do sinal ou não (<strong>LBU</strong> e <strong>LHU</strong>) no armazenamento. Não confundir com o sinal extendido do imediato/offset, aqui me refiro ao valor carregado da memória que se for por exemplo um byte o bit de sinal desse byte ( bit 7 ) será extendido no registrador <strong>rd</strong> ou não.</p>

<table>
  <thead>
    <tr>
      <th>imm[11:0]</th>
      <th>rs1</th>
      <th>funct3</th>
      <th>rd</th>
      <th>op</th>
      <th>instrução</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>xxxxxxxxxxxx</td>
      <td>rs1</td>
      <td>000</td>
      <td>rd</td>
      <td>0000011</td>
      <td>LB</td>
    </tr>
    <tr>
      <td>xxxxxxxxxxxx</td>
      <td>rs1</td>
      <td>001</td>
      <td>rd</td>
      <td>0000011</td>
      <td>LH</td>
    </tr>
    <tr>
      <td>xxxxxxxxxxxx</td>
      <td>rs1</td>
      <td>010</td>
      <td>rd</td>
      <td>0000011</td>
      <td>LW</td>
    </tr>
    <tr>
      <td>xxxxxxxxxxxx</td>
      <td>rs1</td>
      <td>100</td>
      <td>rd</td>
      <td>0000011</td>
      <td>LBU</td>
    </tr>
    <tr>
      <td>xxxxxxxxxxxx</td>
      <td>rs1</td>
      <td>101</td>
      <td>rd</td>
      <td>0000011</td>
      <td>LHU</td>
    </tr>
  </tbody>
</table>

<h4 id="store">Store</h4>

<p><strong>Store</strong> tem tipo próprio denominado tipo S. O imediato (<em>offset</em>) foi divido em duas partes na instrução e localiza-se nos bits <code class="language-plaintext highlighter-rouge">ins[31:25]</code> e <code class="language-plaintext highlighter-rouge">ins[11:7]</code> que juntos montam o imediato de 12 bits que novamente tem seu sinal extendido e é somado ao conteúdo do registrador <strong>rs1</strong> para indicar o endereço da memória que será gravada com o conteúdo do registrador <strong>rs2</strong>.</p>

<p><img src="/assets/imgs/riscv/riscv-store.svg" alt="" /></p>

<p>Por ser uma CPU moderna e bem projetada percebe-se que <strong>rd</strong> de outros tipos virou <code class="language-plaintext highlighter-rouge">imm[4:0]</code> o que facilita na extração desses bits permitindo utilizar código já existente.</p>

<table>
  <thead>
    <tr>
      <th>imm[11:5]</th>
      <th>rs2</th>
      <th>rs1</th>
      <th>funct3</th>
      <th>imm[4:0]</th>
      <th>op</th>
      <th>instrução</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>xxxxxxx</td>
      <td>rs2</td>
      <td>rs1</td>
      <td>000</td>
      <td>xxxxx</td>
      <td>0100011</td>
      <td>SB</td>
    </tr>
    <tr>
      <td>xxxxxxx</td>
      <td>rs2</td>
      <td>rs1</td>
      <td>001</td>
      <td>xxxxx</td>
      <td>0100011</td>
      <td>SH</td>
    </tr>
    <tr>
      <td>xxxxxxx</td>
      <td>rs2</td>
      <td>rs1</td>
      <td>010</td>
      <td>xxxxx</td>
      <td>0100011</td>
      <td>SW</td>
    </tr>
  </tbody>
</table>

<h3 id="tipo-b">Tipo B</h3>

<p>Esse conjunto reúne as instruções de salto condicional. Novamente aqui temos algumas diferenças que podem surpreender aqueles acostumados com x86, m68k: Não há flags condicionais, as operações lógicas são efetuadas entre rs1 e rs2. BEQ, por exemplo, compara rs1 e rs2, se forem iguais então salta para o destino, se diferente continua na próxima instrução.</p>

<p><img src="/assets/imgs/riscv/riscv-b.svg" alt="" /></p>

<p>As instruções B carregam um <em>imediato</em> de 12 bits com sinal e como se pode ver na figura acima eles estão espalhados pela instrução. Perceba que no <em>deslocamento</em> final (32 bits) o <code class="language-plaintext highlighter-rouge">bit 0</code> tem valor <code class="language-plaintext highlighter-rouge">0</code>; como as instruções no RISC-V tem tamanho 32 bits ou 16 bits, nenhuma instrução estará em endereço com <code class="language-plaintext highlighter-rouge">bit[0] = 1</code>, sempre será com <code class="language-plaintext highlighter-rouge">bit[0] = 0</code>, então justifica-se deslocar o <em>deslocamento</em> de 12 bits um bit a esquerda para aumentar o range de deslocamento do salto.
Novamente o sinal é extendido no imediato final.</p>

<p>Montado o <em>deslocamento</em> final, <code class="language-plaintext highlighter-rouge">funct3</code> seleciona a operação lógica entre <strong>rs1</strong> e <strong>rs2</strong>, o resultado da operação é descartado, porém ser for verdadeira o <em>deslocamento</em> somado ao PC da instrução será o pŕoximo PC, caso contrário a próxima instrução será executada (PC+4). Como o sinal é extendido o deslocamento pode ocorrer para frente do PC ou para trás em uma faixa (range) de +-4KiB.</p>

<p>Na ilustração eu não atribui a soma do <em>deslocamento</em> à ALU, isso é uma decisão do projetista, ele pode usar a ALU para somar o <em>deslocamento</em> ou usar um circuito separado para essa soma. As operações lógicas também podem ser executadas pela ALU ou em circuito separado.</p>

<p>Em arquitetura com pipeline saltar para um instrução significa descartar as instruções que já estão no pipeline.</p>

<table>
  <thead>
    <tr>
      <th>[12]</th>
      <th>imm[10:5]</th>
      <th>rs2</th>
      <th>rs1</th>
      <th>funct3</th>
      <th>imm[4:1]</th>
      <th>[11]</th>
      <th>op</th>
      <th>instrução</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>x</td>
      <td>xxxxxx</td>
      <td>rs2</td>
      <td>rs1</td>
      <td>000</td>
      <td>xxxx</td>
      <td>x</td>
      <td>1100011</td>
      <td>BEQ</td>
    </tr>
    <tr>
      <td>x</td>
      <td>xxxxxx</td>
      <td>rs2</td>
      <td>rs1</td>
      <td>001</td>
      <td>xxxx</td>
      <td>x</td>
      <td>1100011</td>
      <td>BNE</td>
    </tr>
    <tr>
      <td>x</td>
      <td>xxxxxx</td>
      <td>rs2</td>
      <td>rs1</td>
      <td>100</td>
      <td>xxxx</td>
      <td>x</td>
      <td>1100011</td>
      <td>BLT</td>
    </tr>
    <tr>
      <td>x</td>
      <td>xxxxxx</td>
      <td>rs2</td>
      <td>rs1</td>
      <td>101</td>
      <td>xxxx</td>
      <td>x</td>
      <td>1100011</td>
      <td>BGE</td>
    </tr>
    <tr>
      <td>x</td>
      <td>xxxxxx</td>
      <td>rs2</td>
      <td>rs1</td>
      <td>110</td>
      <td>xxxx</td>
      <td>x</td>
      <td>1100011</td>
      <td>BLTU</td>
    </tr>
    <tr>
      <td>x</td>
      <td>xxxxxx</td>
      <td>rs2</td>
      <td>rs1</td>
      <td>111</td>
      <td>xxxx</td>
      <td>x</td>
      <td>1100011</td>
      <td>BGEU</td>
    </tr>
  </tbody>
</table>

<p>Em verilog a extração dos bits do imediato pode ser feita facilmente com o código sugerido abaixo:</p>

<pre><code class="language-Verilog">wire [31:0]  IMM_B             =   {{20{INS[31]}},INS[7],INS[30:25],INS[11:8],1'b0};
</code></pre>

<p>E no caso de uma emulador C/C++:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int32_t</span> <span class="n">imm_b</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">imm_b</span>        <span class="o">|=</span>  <span class="p">(</span><span class="n">INS</span> <span class="o">&amp;</span> <span class="mh">0x80</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">;</span>  <span class="c1">// imm11</span>
<span class="n">imm_b</span>        <span class="o">|=</span>  <span class="p">(</span><span class="n">INS</span> <span class="o">&amp;</span> <span class="mh">0xf00</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">7</span><span class="p">;</span> <span class="c1">// imm4_1</span>
<span class="n">imm_b</span>        <span class="o">|=</span>  <span class="p">(</span><span class="n">INS</span> <span class="o">&amp;</span> <span class="mh">0x7E000000</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">20</span><span class="p">;</span> <span class="c1">// imm4_1</span>

<span class="c1">// Sinaliza (sign-extend) se bit 12 estava setado</span>
<span class="k">if</span> <span class="p">(</span><span class="n">INS</span> <span class="o">&amp;</span> <span class="mh">0x80000000</span><span class="p">)</span> <span class="p">{</span>             <span class="c1">// se bit 12 está em 1</span>
    <span class="n">imm_b</span> <span class="o">|=</span> <span class="mh">0xFFFFE000</span><span class="p">;</span>             <span class="c1">// extende o sinal até 32 bits</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="tipo-j-jal-e-jalr">Tipo J, JAL e JALR</h3>

<p>Há duas instruções de salto incondicional: JAL e JALR. JAL tem codificação do Tipo J e JALR do Tipo I. Ambas as instruções salvam o endereço da próxima instrução no registrador <strong>rd</strong> e somam um deslocamento ao PC atual.</p>

<h4 id="jal">JAL</h4>

<p>O deslocamento de JAL é diretamente extraído do imediato de 20 bits contido em sua instrução, enquanto na instrução JALR o deslocamento é uma soma do imediato de 12 bits e o registrador <strong>rs1</strong>. Dessa forma JAL pode saltar em uma faixa (range) de até +-1MiB enquanto JALR pode saltar em toda a faixa de 32 bits desde que <strong>rs1</strong> seja previamente carregado.</p>

<p>Observe que salvar a próxima instrução e saltar é uma chamada de sub-rotina com retorno, porém não há nenhum salvamento automático da próxima instrução na memória, a sub-rotina é que deverá preservar <strong>rd</strong> para poder retornar ao ponto posterior a chamada.
Se o salto não for para uma sub-rotina com retorno basta chamar JAL/JALR com <code class="language-plaintext highlighter-rouge">rd=x0</code> descartando assim <code class="language-plaintext highlighter-rouge">PC+4</code>.</p>

<p><img src="/assets/imgs/riscv/riscv-jal.svg" alt="" /></p>

<p>Como se pode ver na ilustração, a extração do imediato do JAL é complicada. O deslocamento consiste então em 20 bits com sinal que é somado ao PC atual. O <code class="language-plaintext highlighter-rouge">PC+4</code> é gravado no registrador <strong>rd</strong> que poderá então ser utilizado como retorno na chamada da sub-rotina. Novamente percebe-se que a arquitetura RISC-V é minima, não há instruções de retorno de sub-rotina nem de interrupção.</p>

<table>
  <thead>
    <tr>
      <th>[20]</th>
      <th>imm[10:1]</th>
      <th>[11]</th>
      <th>imm[19:12]</th>
      <th>rd</th>
      <th>opcode</th>
      <th>instrução</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>x</td>
      <td>xxxxxxxxxx</td>
      <td>x</td>
      <td>xxxxxxxx</td>
      <td>xxxxx</td>
      <td>1101111</td>
      <td>JAL</td>
    </tr>
  </tbody>
</table>

<div class="language-verilog highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">wire</span> <span class="p">[</span><span class="mi">31</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>     <span class="n">imm_j</span>   <span class="o">=</span>   <span class="o">{{</span><span class="mi">12</span><span class="o">{</span><span class="n">IF</span><span class="p">[</span><span class="mi">31</span><span class="p">]</span><span class="o">}}</span><span class="p">,</span><span class="n">IF</span><span class="p">[</span><span class="mi">19</span><span class="o">:</span><span class="mi">12</span><span class="p">],</span><span class="n">IF</span><span class="p">[</span><span class="mi">20</span><span class="p">],</span><span class="n">IF</span><span class="p">[</span><span class="mi">30</span><span class="o">:</span><span class="mi">21</span><span class="p">],</span><span class="mb">1'b0</span><span class="o">}</span><span class="p">;</span>
</code></pre></div></div>

<p>Em C/C++ a extração pode ser feita com código sugerido abaixo.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int32_t</span> <span class="n">imm_b</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">imm_b</span>        <span class="o">|=</span> <span class="p">(</span><span class="n">INS</span> <span class="o">&amp;</span> <span class="mb">0b01111111111000000000000000000000</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">20</span><span class="p">;</span> <span class="c1">// imm10_1</span>
<span class="n">imm_b</span>        <span class="o">|=</span> <span class="p">(</span><span class="n">INS</span> <span class="o">&amp;</span> <span class="mb">0b00000000000011111111000000000000</span><span class="p">);</span>       <span class="c1">// imm19_12  </span>
<span class="n">imm_b</span>        <span class="o">|=</span> <span class="p">(</span><span class="n">INS</span> <span class="o">&amp;</span> <span class="mb">0b00000000000100000000000000000000</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">9</span><span class="p">;</span>  <span class="c1">// imm11  </span>

<span class="k">if</span> <span class="p">((</span><span class="n">INS</span> <span class="o">&amp;</span> <span class="mh">0x80000000</span><span class="p">))</span>
    <span class="n">imm_b</span> <span class="o">|=</span> <span class="mh">0xFFF00000</span><span class="p">;</span>
</code></pre></div></div>

<h4 id="jalr">JALR</h4>

<p>Enquanto os saltos condicionais tem um range útil de 4KiB de salto e o JAL de 1MiB o JALR preenche a necessidade de se saltar para toda a faixa de 32 bits de endereçamento. Ela consegue fazer isso utilizando um registrador <strong>rs1</strong> como endereço base que é somado ao imediato da instrução consistindo em 12 bits com sinal, como o imediato só consegue um salto na faixa de 4KiB o conteúdo do registrador <strong>rs1</strong> é que de fato permitirá saltos em toda a faixa de 32 bits. Assim como JAL, JALR guarda <code class="language-plaintext highlighter-rouge">PC+4</code> no registrador <strong>rd</strong>.</p>

<p><img src="/assets/imgs/riscv/riscv-jalr.svg" alt="" /></p>

<p>Como JALR é do Tipo I, a extração de seu imediato de 12 bits já foi explorada e o mesmo código poderá ser utilizado. Como todo a faixa de 32 bits é alcançável através de <strong>rs1</strong>, ao contrário do JAL, JALR não tem o <code class="language-plaintext highlighter-rouge">bit[0] == 0</code>, podendo então inclusive dar saltos em endereços não múltiplos de 2.</p>

<table>
  <thead>
    <tr>
      <th>imm[11:0]</th>
      <th>rs1</th>
      <th>funct3</th>
      <th>rd</th>
      <th>op</th>
      <th>instrução</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>xxxxxxxxxxxx</td>
      <td>rs1</td>
      <td>000</td>
      <td>rd</td>
      <td>1100111</td>
      <td>JALR</td>
    </tr>
  </tbody>
</table>

<div class="destaque br bl amarelo">
No ARM em modo ARM (32 bits) se ocorrer um branch (salto) para um endereço que não seja múltiplo de 4 uma exceção de alinhamento (Alignment Fault) será disparada, no modo Thumb se o endereço não for par ocorre a mesma exceção. E no RISC-V? Uma exceção <em>instruction-address-misaligned</em> é disparada caso um salto tenha endereço que não seja multiplo de 4 ou par no caso da extensão C (compressed) estar presente.
</div>

<h3 id="tipo-u">Tipo U</h3>

<p>Se você chegou até aqui, percebeu que a única forma de carregar um registrador até agora é com as instruções Tipo I que contém um imediato de 12 bits. Mas como carregar o restante dos 20 bits de um registrador? Há duas instruções que complementam a carga dos registradores: LUI e AUIPC.</p>

<h4 id="lui">LUI</h4>

<p>LUI (load upper immediate) carrega os 20 bits mais significativos do registrador <strong>rd</strong> com o valor imediato, zerando os 12 bits inferiores. Para carregar uma constante de 32 bits a instrução LUI é usada em conjunto com uma instrução do Tipo I, como a ADDI, utiilizando o registrador x0. De fato é um casamento de instruções tão importante que a maioria dos compiladores utiliza uma macro chamada <code class="language-plaintext highlighter-rouge">li</code> (load immediate) para carregar um registrador. Se o compilador detectar que a constante cabe em 12 bits, apenas uma instrução ADDI será emitida. Caso contrário, ele usará uma combinação de LUI e ADDI para compor o valor completo.</p>

<p><img src="/assets/imgs/riscv/riscv-lui.svg" alt="" /></p>

<h4 id="auipc">AUIPC</h4>

<p>A instrução AUIPC (Add Upper Immediate to PC) soma um imediato ao valor atual do contador de programa (PC) e armazena o resultado no registrador rd.</p>

<p>Essa instrução é fundamental para permitir que executáveis sejam independentes da posição de memória (PIE) — como acontece em bibliotecas dinâmicas (DLLs), plugins e sistemas com ASLR.</p>

<p>Suponha que você precise chamar uma sub-rotina que, no momento da compilação, está localizada K bytes abaixo da instrução atual. Como o programa poderá ser carregado em posições diferentes da memória, você não pode usar um endereço absoluto.</p>

<p>Com AUIPC, é possível gerar um endereço relativo ao PC, somando o deslocamento K e armazenando o resultado em um registrador. Em seguida, você pode usar uma instrução como JALR para efetuar o salto para a sub-rotina.</p>

<p><img src="/assets/imgs/riscv/riscv-auipc.svg" alt="" /></p>

<table>
  <thead>
    <tr>
      <th>imm[31:12] (20 bits)</th>
      <th>rd (5 bits)</th>
      <th>opcode (7 bits)</th>
      <th>Instrução</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>xxxxxxxxxxxxxxxxxxxx</td>
      <td>xxxxx</td>
      <td>0110111</td>
      <td>LUI</td>
    </tr>
    <tr>
      <td>xxxxxxxxxxxxxxxxxxxx</td>
      <td>xxxxx</td>
      <td>0010111</td>
      <td>AUIPC</td>
    </tr>
  </tbody>
</table>

<p>A extração do imediato é direto:</p>

<p>Verilog</p>

<div class="language-verilog highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">wire</span> <span class="p">[</span><span class="mi">31</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>     <span class="n">imm_u</span>   <span class="o">=</span>   <span class="o">{</span><span class="n">INS</span><span class="p">[</span><span class="mi">31</span><span class="o">:</span><span class="mi">12</span><span class="p">],</span><span class="mb">12'b0</span><span class="o">}</span><span class="p">;</span>
</code></pre></div></div>

<p>C/C++</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int32_t</span> <span class="n">imm_u</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int32_t</span><span class="p">)(</span><span class="n">INS</span> <span class="o">&amp;</span> <span class="mh">0xFFFFF000</span><span class="p">);</span>
</code></pre></div></div>

<h3 id="tabela-resumo-das-instruções">Tabela resumo das instruções</h3>

<table>
<thead>
    <tr>
      <th colspan="13"></th>
      <th>Opcode [6:0]</th>
      <th>Instrução</th>
    </tr>
  </thead>
<tbody>
<tr>
<td colspan="10"><p>imm[31:12]</p></td>
<td colspan="2"><p>rd</p></td>
<td colspan="2"><p>0110111</p></td>
<td><p>LUI</p></td>
</tr>
<tr>
<td colspan="10"><p>imm[31:12]</p></td>
<td colspan="2"><p>rd</p></td>
<td colspan="2"><p>0010111</p></td>
<td><p>AUIPC</p></td>
</tr>
<tr>
<td colspan="10"><p>imm[20|10:1|11|19:12]</p></td>
<td colspan="2"><p>rd</p></td>
<td colspan="2"><p>1101111</p></td>
<td><p>JAL</p></td>
</tr>
<tr>
<td colspan="6"><p>imm[11:0]</p></td>
<td colspan="2"><p>rs1</p></td>
<td colspan="2"><p>000</p></td>
<td colspan="2"><p>rd</p></td>
<td colspan="2"><p>1100111</p></td>
<td><p>JALR</p></td>
</tr>
<tr>
<td colspan="4"><p>imm[12|10:5]</p></td>
<td colspan="2"><p>rs2</p></td>
<td colspan="2"><p>rs1</p></td>
<td colspan="2"><p>000</p></td>
<td colspan="2"><p>imm[4:1|11]</p></td>
<td colspan="2"><p>1100011</p></td>
<td><p>BEQ</p></td>
</tr>
<tr>
<td colspan="4"><p>imm[12|10:5]</p></td>
<td colspan="2"><p>rs2</p></td>
<td colspan="2"><p>rs1</p></td>
<td colspan="2"><p>001</p></td>
<td colspan="2"><p>imm[4:1|11]</p></td>
<td colspan="2"><p>1100011</p></td>
<td><p>BNE</p></td>
</tr>
<tr>
<td colspan="4"><p>imm[12|10:5]</p></td>
<td colspan="2"><p>rs2</p></td>
<td colspan="2"><p>rs1</p></td>
<td colspan="2"><p>100</p></td>
<td colspan="2"><p>imm[4:1|11]</p></td>
<td colspan="2"><p>1100011</p></td>
<td><p>BLT</p></td>
</tr>
<tr>
<td colspan="4"><p>imm[12|10:5]</p></td>
<td colspan="2"><p>rs2</p></td>
<td colspan="2"><p>rs1</p></td>
<td colspan="2"><p>101</p></td>
<td colspan="2"><p>imm[4:1|11]</p></td>
<td colspan="2"><p>1100011</p></td>
<td><p>BGE</p></td>
</tr>
<tr>
<td colspan="4"><p>imm[12|10:5]</p></td>
<td colspan="2"><p>rs2</p></td>
<td colspan="2"><p>rs1</p></td>
<td colspan="2"><p>110</p></td>
<td colspan="2"><p>imm[4:1|11]</p></td>
<td colspan="2"><p>1100011</p></td>
<td><p>BLTU</p></td>
</tr>
<tr>
<td colspan="4"><p>imm[12|10:5]</p></td>
<td colspan="2"><p>rs2</p></td>
<td colspan="2"><p>rs1</p></td>
<td colspan="2"><p>111</p></td>
<td colspan="2"><p>imm[4:1|11]</p></td>
<td colspan="2"><p>1100011</p></td>
<td><p>BGEU</p></td>
</tr>
<tr>
<td colspan="6"><p>imm[11:0]</p></td>
<td colspan="2"><p>rs1</p></td>
<td colspan="2"><p>000</p></td>
<td colspan="2"><p>rd</p></td>
<td colspan="2"><p>0000011</p></td>
<td><p>LB</p></td>
</tr>
<tr>
<td colspan="6"><p>imm[11:0]</p></td>
<td colspan="2"><p>rs1</p></td>
<td colspan="2"><p>001</p></td>
<td colspan="2"><p>rd</p></td>
<td colspan="2"><p>0000011</p></td>
<td><p>LH</p></td>
</tr>
<tr>
<td colspan="6"><p>imm[11:0]</p></td>
<td colspan="2"><p>rs1</p></td>
<td colspan="2"><p>010</p></td>
<td colspan="2"><p>rd</p></td>
<td colspan="2"><p>0000011</p></td>
<td><p>LW</p></td>
</tr>
<tr>
<td colspan="6"><p>imm[11:0]</p></td>
<td colspan="2"><p>rs1</p></td>
<td colspan="2"><p>100</p></td>
<td colspan="2"><p>rd</p></td>
<td colspan="2"><p>0000011</p></td>
<td><p>LBU</p></td>
</tr>
<tr>
<td colspan="6"><p>imm[11:0]</p></td>
<td colspan="2"><p>rs1</p></td>
<td colspan="2"><p>101</p></td>
<td colspan="2"><p>rd</p></td>
<td colspan="2"><p>0000011</p></td>
<td><p>LHU</p></td>
</tr>
<tr>
<td colspan="4"><p>imm[11:5]</p></td>
<td colspan="2"><p>rs2</p></td>
<td colspan="2"><p>rs1</p></td>
<td colspan="2"><p>000</p></td>
<td colspan="2"><p>imm[4:0]</p></td>
<td colspan="2"><p>0100011</p></td>
<td><p>SB</p></td>
</tr>
<tr>
<td colspan="4"><p>imm[11:5]</p></td>
<td colspan="2"><p>rs2</p></td>
<td colspan="2"><p>rs1</p></td>
<td colspan="2"><p>001</p></td>
<td colspan="2"><p>imm[4:0]</p></td>
<td colspan="2"><p>0100011</p></td>
<td><p>SH</p></td>
</tr>
<tr>
<td colspan="4"><p>imm[11:5]</p></td>
<td colspan="2"><p>rs2</p></td>
<td colspan="2"><p>rs1</p></td>
<td colspan="2"><p>010</p></td>
<td colspan="2"><p>imm[4:0]</p></td>
<td colspan="2"><p>0100011</p></td>
<td><p>SW</p></td>
</tr>
<tr>
<td colspan="6"><p>imm[11:0]</p></td>
<td colspan="2"><p>rs1</p></td>
<td colspan="2"><p>000</p></td>
<td colspan="2"><p>rd</p></td>
<td colspan="2"><p>0010011</p></td>
<td><p>ADDI</p></td>
</tr>
<tr>
<td colspan="6"><p>imm[11:0]</p></td>
<td colspan="2"><p>rs1</p></td>
<td colspan="2"><p>010</p></td>
<td colspan="2"><p>rd</p></td>
<td colspan="2"><p>0010011</p></td>
<td><p>SLTI</p></td>
</tr>
<tr>
<td colspan="6"><p>imm[11:0]</p></td>
<td colspan="2"><p>rs1</p></td>
<td colspan="2"><p>011</p></td>
<td colspan="2"><p>rd</p></td>
<td colspan="2"><p>0010011</p></td>
<td><p>SLTIU</p></td>
</tr>
<tr>
<td colspan="6"><p>imm[11:0]</p></td>
<td colspan="2"><p>rs1</p></td>
<td colspan="2"><p>100</p></td>
<td colspan="2"><p>rd</p></td>
<td colspan="2"><p>0010011</p></td>
<td><p>XORI</p></td>
</tr>
<tr>
<td colspan="6"><p>imm[11:0]</p></td>
<td colspan="2"><p>rs1</p></td>
<td colspan="2"><p>110</p></td>
<td colspan="2"><p>rd</p></td>
<td colspan="2"><p>0010011</p></td>
<td><p>ORI</p></td>
</tr>
<tr>
<td colspan="6"><p>imm[11:0]</p></td>
<td colspan="2"><p>rs1</p></td>
<td colspan="2"><p>111</p></td>
<td colspan="2"><p>rd</p></td>
<td colspan="2"><p>0010011</p></td>
<td><p>ANDI</p></td>
</tr>
<tr>
<td colspan="4"><p>0000000</p></td>
<td colspan="2"><p>shamt</p></td>
<td colspan="2"><p>rs1</p></td>
<td colspan="2"><p>001</p></td>
<td colspan="2"><p>rd</p></td>
<td colspan="2"><p>0010011</p></td>
<td><p>SLLI</p></td>
</tr>
<tr>
<td colspan="4"><p>0000000</p></td>
<td colspan="2"><p>shamt</p></td>
<td colspan="2"><p>rs1</p></td>
<td colspan="2"><p>101</p></td>
<td colspan="2"><p>rd</p></td>
<td colspan="2"><p>0010011</p></td>
<td><p>SRLI</p></td>
</tr>
<tr>
<td colspan="4"><p>0100000</p></td>
<td colspan="2"><p>shamt</p></td>
<td colspan="2"><p>rs1</p></td>
<td colspan="2"><p>101</p></td>
<td colspan="2"><p>rd</p></td>
<td colspan="2"><p>0010011</p></td>
<td><p>SRAI</p></td>
</tr>
<tr>
<td colspan="4"><p>0000000</p></td>
<td colspan="2"><p>rs2</p></td>
<td colspan="2"><p>rs1</p></td>
<td colspan="2"><p>000</p></td>
<td colspan="2"><p>rd</p></td>
<td colspan="2"><p>0110011</p></td>
<td><p>ADD</p></td>
</tr>
<tr>
<td colspan="4"><p>0100000</p></td>
<td colspan="2"><p>rs2</p></td>
<td colspan="2"><p>rs1</p></td>
<td colspan="2"><p>000</p></td>
<td colspan="2"><p>rd</p></td>
<td colspan="2"><p>0110011</p></td>
<td><p>SUB</p></td>
</tr>
<tr>
<td colspan="4"><p>0000000</p></td>
<td colspan="2"><p>rs2</p></td>
<td colspan="2"><p>rs1</p></td>
<td colspan="2"><p>001</p></td>
<td colspan="2"><p>rd</p></td>
<td colspan="2"><p>0110011</p></td>
<td><p>SLL</p></td>
</tr>
<tr>
<td colspan="4"><p>0000000</p></td>
<td colspan="2"><p>rs2</p></td>
<td colspan="2"><p>rs1</p></td>
<td colspan="2"><p>010</p></td>
<td colspan="2"><p>rd</p></td>
<td colspan="2"><p>0110011</p></td>
<td><p>SLT</p></td>
</tr>
<tr>
<td colspan="4"><p>0000000</p></td>
<td colspan="2"><p>rs2</p></td>
<td colspan="2"><p>rs1</p></td>
<td colspan="2"><p>011</p></td>
<td colspan="2"><p>rd</p></td>
<td colspan="2"><p>0110011</p></td>
<td><p>SLTU</p></td>
</tr>
<tr>
<td colspan="4"><p>0000000</p></td>
<td colspan="2"><p>rs2</p></td>
<td colspan="2"><p>rs1</p></td>
<td colspan="2"><p>100</p></td>
<td colspan="2"><p>rd</p></td>
<td colspan="2"><p>0110011</p></td>
<td><p>XOR</p></td>
</tr>
<tr>
<td colspan="4"><p>0000000</p></td>
<td colspan="2"><p>rs2</p></td>
<td colspan="2"><p>rs1</p></td>
<td colspan="2"><p>101</p></td>
<td colspan="2"><p>rd</p></td>
<td colspan="2"><p>0110011</p></td>
<td><p>SRL</p></td>
</tr>
<tr>
<td colspan="4"><p>0100000</p></td>
<td colspan="2"><p>rs2</p></td>
<td colspan="2"><p>rs1</p></td>
<td colspan="2"><p>101</p></td>
<td colspan="2"><p>rd</p></td>
<td colspan="2"><p>0110011</p></td>
<td><p>SRA</p></td>
</tr>
<tr>
<td colspan="4"><p>0000000</p></td>
<td colspan="2"><p>rs2</p></td>
<td colspan="2"><p>rs1</p></td>
<td colspan="2"><p>110</p></td>
<td colspan="2"><p>rd</p></td>
<td colspan="2"><p>0110011</p></td>
<td><p>OR</p></td>
</tr>
<tr>
<td colspan="4"><p>0000000</p></td>
<td colspan="2"><p>rs2</p></td>
<td colspan="2"><p>rs1</p></td>
<td colspan="2"><p>111</p></td>
<td colspan="2"><p>rd</p></td>
<td colspan="2"><p>0110011</p></td>
<td><p>AND</p></td>
</tr>
<tr>
<td colspan="3"><p>fm</p></td>
<td colspan="2"><p>pred</p></td>
<td><p>succ</p></td>
<td colspan="2"><p>rs1</p></td>
<td colspan="2"><p>000</p></td>
<td colspan="2"><p>rd</p></td>
<td colspan="2"><p>0001111</p></td>
<td><p>FENCE</p></td>
</tr>
<tr>
<td colspan="3"><p>1000</p></td>
<td colspan="2"><p>0011</p></td>
<td><p>0011</p></td>
<td colspan="2"><p>00000</p></td>
<td colspan="2"><p>000</p></td>
<td colspan="2"><p>00000</p></td>
<td colspan="2"><p>0001111</p></td>
<td><p>FENCE.TSO</p></td>
</tr>
<tr>
<td colspan="3"><p>0000</p></td>
<td colspan="2"><p>0001</p></td>
<td><p>0000</p></td>
<td colspan="2"><p>00000</p></td>
<td colspan="2"><p>000</p></td>
<td colspan="2"><p>00000</p></td>
<td colspan="2"><p>0001111</p></td>
<td><p>PAUSE</p></td>
</tr>
<tr>
<td colspan="6"><p>000000000000</p></td>
<td colspan="2"><p>00000</p></td>
<td colspan="2"><p>000</p></td>
<td colspan="2"><p>00000</p></td>
<td colspan="2"><p>1110011</p></td>
<td><p>ECALL</p></td>
</tr>
<tr>
<td colspan="6"><p>000000000001</p></td>
<td colspan="2"><p>00000</p></td>
<td colspan="2"><p>000</p></td>
<td colspan="2"><p>00000</p></td>
<td colspan="2"><p>1110011</p></td>
<td><p>EBREAK</p></td>
</tr>
</tbody>
</table>


  </article>

</div>
</div>
</div>
</section>

<section class="section">
  <hr/>
  <nav class="level is-mobile">

    <div class="level-item">      
      
      
      <div>
        <p class="heading"><strong>Veja Também:</strong></p>
        <a href="/aplicadas/2025/03/29/estimar-raio-capacitor-jargao-estatistica.html"><small>Perdi uma placa por utilizar um estimador estatístico errado - Matemática</small></br></a>
        <a href=""><small></small></a>
      </div>
    </div>
  </nav>
</section>
<section class="section">
  <div id="disqus_thread"></div>
<script>
    (function() { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');
    s.src = 'https://fabiovila-github-io.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</section>



<footer class="footer has-background-dark has-text-white">
  <div class="content has-text-centered">
    <p>
      <strong>Fabio Vila</strong> by <a href="https://fabiovila-github-io">Fabio Vila</a>.
      The source code is licensed
      <a rel="license" href="http://creativecommons.org/licenses/by/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by/4.0/88x31.png" /></a><br />This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a>.

    </p>
  </div>
</footer>
</body>
</html>

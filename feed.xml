<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>Fabio</title>
    <link href="https://fabiovila.github.io/feed.xml" rel="self" />
    <link href="https://fabiovila.github.io" />
    <updated>2021-06-02T14:17:13-03:00</updated>
    <author>
        <name>Fabio</name>
    </author>
    <id>https://fabiovila.github.io</id>

    <entry>
        <title>Rede neural em python numpy para iris dataset</title>
        <author>
            <name>Fabio</name>
        </author>
        <link href="https://fabiovila.github.io/rede-neural-em-python-numpy-para-iris-dataset.html"/>
        <id>https://fabiovila.github.io/rede-neural-em-python-numpy-para-iris-dataset.html</id>
            <category term="redes-neurais"/>
            <category term="python"/>
            <category term="numpy"/>
            <category term="machine-learning"/>

        <updated>2021-06-02T14:17:13-03:00</updated>
            <summary>
                <![CDATA[
                    O entendimento de como funciona o treinamento das redes neurais é um processo difícil por envolver conhecimentos de diversas áreas e matemática de nível superior. E mesmo para quem tem cálculo 1 e 2 quando se depara com a derivação parcial do erro com base&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                <p>O entendimento de como funciona o treinamento das redes neurais é um processo difícil por envolver conhecimentos de diversas áreas e matemática de nível superior. E mesmo para quem tem cálculo 1 e 2 quando se depara com a <em>derivação parcial do erro com base nos pesos</em> o entendimento não é trivial.</p>
<p>Ainda ficarei devendo essa explicação completa, mas enquanto isso segue este programa que fiz para python/numpy para treinar o dataset Iris usando duas camadas de redes neurais ativadas por sigmoide e treinadas usando retro-propagação com AdaGrad.</p>
<p>Sem o AdaGrad o treinamento se torna instável e pode ficar preso em um minimo local e nunca mais sair.</p>
<p>A convergência do Erro vai depender de cada execução devido a inicialização aleatória dos pesos, pode acontecer até mesmo de ainda sim ficar preso em um minimo local e não sair mais. Basta executar novamente que novos pesos aleatórios são inicializados.</p>
<p><a href="https://fabiovila.github.io/iris.data.csv" target="_blank" rel="noopener noreferrer" download>Link para download do iris dataset.</a></p>
<pre><code class="language-python">
import numpy as np

# Ativação sigmoid
def sig(n):
    return 1 / ( 1 + np.exp(-n))

# Derivada da sigmoid
# Muitos empacam aqui porque envolve cálculo 1 e 2 que só se aprende na faculdade
def dsig(n):
    return n * ( 1 - n)


if __name__ == '__main__':
    np.set_printoptions(precision=2 , suppress=True)

    # o iris.data.csv está organizado da seguinte forma:
    # 5.1,3.5,1.4,0.2,Iris-setosa
    # 4.9,3.0,1.4,0.2,Iris-setosa
    # 4.7,3.2,1.3,0.2,Iris-setosa
    #

    # carrega as quatro primeiras colunas que são os valores coletados na pesquisa
    X       = np.loadtxt('iris.data.csv', delimiter=',', usecols=[0,1,2,3])
    # carrega a última coluna contendo a string que define a categoria
    labels  = np.loadtxt('iris.data.csv', delimiter=',', dtype=str, usecols=[4])
    # Transforma as strings em valores númericos únicos
    l, Yu   = np.unique(labels, return_inverse=True)
    # e finalmente indexa cada valor numerico em um vetor 3 (ou matriz 1x3) 
    Y       = np.array([[0.0,0.0,1.0],[0.0,1.0,0.0],[1.0,0.0,0.0]])[Yu]
    
    r = np.random.randint(0,len(X),size=5)
    for rr in r:
        print ("X:" + str(X[rr]) + " Yu: " + str(Yu[rr]) + " Y: " + str(Y[rr]) + " Label: " + str(labels[rr]) )
    
    # logo os dados serão apresentados da seguinte forma para a rede neural
    # [5.1,3.5,1.4,0.2] - [1.0,0.0,0.0]


    # Dados armazenados, hora de montar a rede neural

    Wx = np.random.uniform(-5.0,5.0, size = (4,8))
    Bx = np.zeros((1,8))

    Wy = np.random.uniform(-5.0,5.0, size = (8,3))
    By = np.zeros((1,3))

    AWx = np.zeros((4,8))
    ABx = np.zeros((1,8))

    AWy = np.zeros((8,3))
    ABy = np.zeros((1,3))

    # faz uma breve previsão com a rede destreinada para observar os cálculos. O Forward
    ox =  sig(X[0] @ Wx + Bx)  # multiplicação de matrizes de X[0] com Wx e soma Bx o resultado é uma matrix e 1 linha e 8 colunas
    oy =  sig(ox @ Wy + By) 
    print(ox , oy)

    #let's cooking! vamos treinar a rede!
    lrate = 0.35
    for epoch in range(10000):
        # gera uma sequencia aleatória para ser usada como indice no próximo for
        # dessa forma os dados serão apresentados a rede de forma aleatória do que na sequência natural do arquivo
        Xr = np.random.permutation(len(X))
        et = 0  # erro total
        #lrate = lrate * 0.9999
        for ite in Xr:
            Xi = X[ite]
            Yi = Y[ite]



            ## o forward

            ox =  sig(Xi @ Wx + Bx)  # multiplicação de matrizes de X[0] com Wx e soma Bx o resultado é uma matrix e 1 linha e 8 colunas
            oy =  sig(ox @ Wy + By)


            ## o backward

            # o erro dessa interação
            e = oy - Yi 
            # a soma dos erros de todas a interações
            et += (e*e).sum()

            b = e * dsig(oy)
            delta = np.outer(ox,b)

            AWy += np.multiply(delta,delta)
            ABy += b*b

            Wy -= lrate * delta / np.sqrt(AWy + 1e-6)
            By -= lrate * b  / np.sqrt(ABy+1e-6)



            # propaga o erro para a camada x
            ex = e @ Wy.T

            # e finalmente atualiza a primeira camada
            b = ex * dsig(ox)
            delta = np.outer(Xi,b)

            AWx += np.multiply(delta,delta)
            ABx += b*b

            Wx -= lrate * delta / np.sqrt(AWx+1e-6)
            Bx -= lrate * b  / np.sqrt(ABx+1e-6)



        print ("Erro: %4.4f Learning Rate: %4.4f"%(et,lrate))
        #input()
            

    for n,xx in enumerate(X):
        ox =  sig(xx @ Wx + Bx)  
        oy =  sig(ox @ Wy + By)
        print ("X:" + str(xx) + " Y: " + str(Y[n]) + " Output: " + str(oy) )</code>  </pre>
            ]]>
        </content>
    </entry>
    <entry>
        <title>Fazendo uma dieta de café da manhã de baixo custo no OR-TOOLs</title>
        <author>
            <name>Fabio</name>
        </author>
        <link href="https://fabiovila.github.io/fazendo-um-cardapio-de-cafe-da-manha-com-calorias-e-baixo-custo-no-or-tools.html"/>
        <id>https://fabiovila.github.io/fazendo-um-cardapio-de-cafe-da-manha-com-calorias-e-baixo-custo-no-or-tools.html</id>
            <category term="python"/>
            <category term="otimização"/>
            <category term="cvxpy"/>

        <updated>2021-05-21T20:32:52-03:00</updated>
            <summary>
                <![CDATA[
                        <img src="https://fabiovila.github.io/media/posts/2/bread-18987_640.jpg" alt="" />
                    Dietas com restrições Um problema comum na nutrição é a confecção de dietas com restrições. As restrições podem ser calóricas ou com ausência de algum componente como a lactose, a gordura, o glúten, etc .... Em geral o custo destas dietas aumentam em relação a&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                    <img src="https://fabiovila.github.io/media/posts/2/bread-18987_640.jpg" alt="" />
                <h2>Dietas com restrições</h2>
<p>Um problema comum na nutrição é a confecção de dietas com restrições. As restrições podem ser calóricas ou com ausência de algum componente como a lactose, a gordura, o glúten, etc ....</p>
<p>Em geral o custo destas dietas aumentam em relação a dieta comum. Para auxiliar na procura de uma dieta barata neste post faremos uma dieta abaixo de uma dada caloria e com menor custo possível usando o otimizador OR-TOOLs.</p>
<p><em>Apesar do título esse post (e meu blog) trata de um exemplo de uso do otimizador OR-TOOLs em Python e tem tópicos de matemática. Se você chegou aqui e é da área da nutrição provavelmente se perderá, porém ao menos ficará o conhecimento intuitivo do uso de softwares para se fazer dietas.</em></p>
<h6>Quantidades praticáveis</h6>
<p>O problema de escolher certos alimentos reduzindo o custo é um problema semelhante ao knapsack. Onde é dado uma lista de alimentos com seus valores calóricos e custos e uma quantidade de calorias máxima e minima que deverão ser respeitados. O objetivo é minimizar o custo da dieta. </p>
<p>Um dos problemas a se resolver é a quantidade impraticável. Não há como quantificar 1.01 ou 0.04 de um Ovo, a dieta deve conter quantidades praticáveis de cada alimento.</p>
<p>Há várias forma de se resolver isso. Uma delas é repetir o alimento com quantidades fracionadas e seguras. Dessa forma teremos $X_{?} - Ovo Inteiro, X_{?} - Meio Ovo$ e assim vai. É uma forma segura pois cada alimento tem fracionamento diferente como por exemplo o Leite que pode ser 1 Copo, 100mL, 1L, 0.1 Litros, 240mL em contraste com o Ovo que só faz sentido valores inteiros.</p>
<p>Entretanto um aumento no número de variáveis degrada a performance do solver. Mas não podemos esquecer que em um ambiente de produção a Nutricionista irá selecionar previamente os alimentos possíveis e ainda deve-se levar em conta que em um café da manhã não se tem muitas opções disponíveis o que torna o problema resolvível em tempo hábil.</p>
<p>Em um ambiente de produção quando a pessoa seleciona Ovo o programa automaticamente trabalha com Ovo inteiro e Meio Ovo. Para evitar que Meio Ovo seja usado mais de uma vez (o que daria um ovo inteiro) podemos restringir o Meio Ovo para somente 1 unidade, entretanto Ovo Inteiro pode ser usado indefinidamente unidades inteiras.</p>
<h6>O problema</h6>
<p>O modelo matemático deste problema é </p>
<div class="defin">
<p>Dados:</p>
<p>$V_{i}$ - Valor calórico do alimento $i$<br><br>$C_{i}$ - Custo em Reais do alimento $i$<br><br>$K$ - Calorias máximas da dieta</p>
<p>$Km$ - Calorias minimas da dieta</p>
<p>$X_{i}$ - Variável de decisão que indica a quantidade do alimento $i$ na dieta, não pode ser Reais pois podemos ter como resultado valores fracionários impraticáveis em alguns alimentos como ovos, pão, queijos.</p>
<p>$X_{i}\leq4$ - Limitamos o número de cada alimento para evitar monotonia da dieta</p>
<p>Onde queremos:</p>
<p>$\quad\min(\sum\nolimits_{X_{i}C_{i}})$</p>
<p>$\quad\text{sujeito a:}$</p>
<p>$\quad\sum\nolimits_{X_{i}V_{i}}\leq K$</p>
<p>$\quad\sum\nolimits_{X_{i}V_{i}}\geq Km$</p>
<p>$\quad X_{i}\in \{0, 0.5, 1, 1.5 , 2 , 2.5 , 3 , 3.5, 4\}$</p>
</div>
<p>$X_{i}$ deve ser maior ou igual a 0 e limitamos os valores para $\{0, 0.5, 1, 1.5 , 2 , 2.5 , 3 , 3.5, 4\}$ para impedir que um ovo tenha 1.01 ou 0.02 de quantidade e no máximo 4  quantidades do alimento para não sair uma dieta com poucos ou um alimento.</p>
<p> </p>
<p> </p>
<p> </p>
            ]]>
        </content>
    </entry>
    <entry>
        <title>O CVXPY para o problema de mochila (knapsack)</title>
        <author>
            <name>Fabio</name>
        </author>
        <link href="https://fabiovila.github.io/o-cvxpy-para-o-problema-de-mochila-knapsack.html"/>
        <id>https://fabiovila.github.io/o-cvxpy-para-o-problema-de-mochila-knapsack.html</id>
            <category term="python"/>
            <category term="otimização"/>
            <category term="cvxpy"/>

        <updated>2021-06-02T13:47:21-03:00</updated>
            <summary>
                <![CDATA[
                        <img src="https://fabiovila.github.io/media/posts/1/Screenshot-from-2021-05-15-17-39-07-2.png" alt="" />
                    CVXPY CVXPY é um framework python para diversos otimizadores com uma linguagem própria e suporte a Numpy. Para instalar o CVXPY use o pip: pip install cvxpy Um dos otimizadores disponíveis é o CBC um otimizador de programação linear inteiro open-source. O CBC pode ser&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                    <img src="https://fabiovila.github.io/media/posts/1/Screenshot-from-2021-05-15-17-39-07-2.png" alt="" />
                <h2>CVXPY</h2>
<p>CVXPY é um framework python para diversos otimizadores com uma linguagem própria e suporte a Numpy.</p>
<p>Para instalar o CVXPY use o pip:</p>
<p><code class="language-bash">pip install cvxpy</code></p>
<p>Um dos otimizadores disponíveis é o <a href="https://projects.coin-or.org/Cbc" target="_blank" rel="noopener noreferrer">CBC</a>  um otimizador de programação linear inteiro open-source. O CBC pode ser usado em linha de comando sem ser necessário o CVXPY, mas neste caso será necessário aprender sua linguagem de entrada. </p>
<p>Também será necessário instalar o CVXOPT:</p>
<p><code class="language-bash">pip install cvxopt</code></p>
<h2>Problema da mochila</h2>
<p>O problema da mochila mais conhecido como knapsack é um problema clássico de otimização combinatória.</p>
<p>O problema consiste em colocar o maior valor possível de itens em uma mochila com certa capacidade de peso. A mochila tem uma capacidade definida de peso. Os itens um peso e um valor. A objetivo é ter o maior valor possível dentro da mochila, ou seja, maximizar o valor.</p>
<p>Esse problema aparece em diversas áreas como a logística, computação e investimentos.</p>
<pre><code class="language-python">import cvxpy as cp
import numpy as np
# Dados de entrada do problema
Valores = np.array([10,13,1,100,45,13,156,76,4,59,97,99])
Pesos = np.array([50,55,10,5,1,98,34,3,9,3,7,19])
Capacidade_Mochila = 100<br>
# Variaveis de decisão<br>
# Cada Item Xi terá valor 1 se estiver na mochila ou 0 se estiver fora
# cp.Variable cria uma variável no CVX ( não confunda cp com np ) do tipo boolean do tamanho da quantidade de itens
<br>Xi = cp.Variable((Valores.size), boolean = True)
<br># Constraints do problema<br>
# A soma total dos pesos dos itens escolhidos por Xi devem ser igual ou menor que a capacidade da mochila                
<br>constraints = [ Xi @ Pesos &lt;= Capacidade_Mochila ]
# Tambem pode ser escrito com o mesmo resultado como:
#constraints = [ cp.sum( cp.multiply (Xi, Pesos ) ) &lt;= Capacidade_Mochila ]
<br># O Objetivo do problema
# é maximizar os valores na mochila<br>
objective = cp.Maximize( Xi @ Valores )
<br># finalmente chamamos o solver com verbose para acompanhar 
# o progresso e a execução máxima de 1hr<br>
prob = cp.Problem(objective, constraints)              
prob.solve(solver=cp.CBC,verbose=True, maximumSeconds = 1 * 60 * 60)         
print("Status          : ", prob.status)
print("Valor encontrado: ", prob.value)
print("Valor de Xi     : ", Xi.value)
    </code></pre>
<p>O problema da mochila tem muitas aplicações práticas principalmente na logística. Imagine uma transportadora que precisa distribuir seus pacotes utilizando vans e caminhões. Cada pacote tem peso, tamanho, localidade, tempo de espera e valor. Um programa de otimização pode ajudar no preenchimento dos caminhões e em aplicações profissionais traçar a rota de distribuição de cada veículo.</p>
<p>Problemas de otimização não acham o melhor valor, porque em geral é uma tarefa impossível (o mais correto seria improvável) de acha-lo devido a explosão combinatória. Por isso são chamados 'otimizadores' porque eles buscam a melhor solução possível, ou seja, uma solução ótima.</p>
            ]]>
        </content>
    </entry>
</feed>

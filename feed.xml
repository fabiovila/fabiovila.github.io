<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>Fabio</title>
    <link href="https://fabiovila.github.io/feed.xml" rel="self" />
    <link href="https://fabiovila.github.io" />
    <updated>2021-12-18T22:59:24-03:00</updated>
    <author>
        <name>Fabio</name>
    </author>
    <id>https://fabiovila.github.io</id>

    <entry>
        <title>Usando Python para ODEs de circuitos elétricos: RL</title>
        <author>
            <name>Fabio</name>
        </author>
        <link href="https://fabiovila.github.io/usando-python-para-solucionar-ode-em-circuitos-eletricos.html"/>
        <id>https://fabiovila.github.io/usando-python-para-solucionar-ode-em-circuitos-eletricos.html</id>

        <updated>2021-12-18T22:59:24-03:00</updated>
            <summary>
                <![CDATA[
                    Neste primeiro post iniciarei uma série de posts tratando da solução de&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                <p>Neste primeiro post iniciarei uma série de posts tratando da solução de circuitos elétricos utilizando Python. Um bom início é o circuito RL pois encontramos nele apenas uma derivada.</p>
<figure class="post__image align-center"><img loading="lazy"  src="https://fabiovila.github.io/media/posts/10/circuit.png" sizes="(max-width: 1024px) 100vw, 1024px" srcset="https://fabiovila.github.io/media/posts/10/responsive/circuit-xs.png 300w ,https://fabiovila.github.io/media/posts/10/responsive/circuit-sm.png 480w ,https://fabiovila.github.io/media/posts/10/responsive/circuit-md.png 768w ,https://fabiovila.github.io/media/posts/10/responsive/circuit-lg.png 1024w"  alt="" width="260" height="180"></figure><br><br>Para uma fonte de 5V o circuito é modelado pela seguinte equação diferencial</p>
<p class="msg msg--highlight ">$\displaystyle 5 = 4700 i{\left(t \right)} + 0.0001 \frac{d}{d t} i{\left(t \right)}$</p>
<p> </p>
<p>Posteriormente iremos usar uma fonte CA senoidal.</p>
<p>Conhecidas como Equações Diferenciais Ordinárias ou abreviadamente ODE essas equações podem ter soluções analítica ou numérica. A solução analítica é a solução como conhecemos na escola ou a simples solução algébrica através de manipulação dos símbolos. Entretanto a solução analítica de uma ODE requer conhecimento de cálculo 2 lecionado no nível superior. </p>
<p>A solução numérica não manipula símbolos, utiliza-se de métodos interativos com tentativa e erros com um certo discernimento de para onde ir em busca da solução. </p>
<p>Veremos neste post os dois métodos utilizando Python. Primeiro faremos alguns imports.</p>
<pre><code class="language-python">
from sympy import *
import numpy as np
from scipy.integrate import solve_ivp
import matplotlib.pyplot as plt
%matplotlib inline
</code></pre>
<h4>Versão analítica com SymPy</h4>
<p>A solução analítica pode ser encontrada utilizando o módulo Sympy. É um módulo promissor, mas ainda está em um nível intermediário de maturidade. Não se compara em poder ao Maxima e o Mathematica.</p>
<p>A solução analítica de uma ODE utilizando o Sympy é encontrada com o comando <code>dsolve</code>.</p>
<pre><code class="language-python">
S = 5
R = 4700
L = 100e-6

t = Symbol('t')
v = Function('v')(t)
i = Function('i')(t)
    
eq = Eq(S,R*i+L*i.diff(t))
eq
</code></pre>
<p>O Sympy exibe em formato tex a equação acima como:</p>
<p class="msg msg--highlight ">$\displaystyle 5 = 4700 i{\left(t \right)} + 0.0001 \frac{d}{d t} i{\left(t \right)}$</p>
<p>E como dito a solução analítica é encontrada pelo comando <code>dsolve</code>: </p>
<pre><code class="language-python">dsolve(eq)
</code></pre>
<p>cuja saída será:</p>
<p class="msg msg--highlight ">$\displaystyle i{\left(t \right)} = C_{1} e^{- 47000000.0 t} + \frac{1}{940}$</p>
<p>Que é a função de <strong>i em t </strong>como desejamos. C_1 é uma constante que como toda equação diferencial e sistemas físicos que armazenam energia essa constante define a condição inicial da função, oras, temos um indutor no circuito que INICIALMENTE pode ter um campo magnético de valor 0 ou qualquer outro valor que iria interferir no início do circuito. Cabe a nós dizer qual é esse campo. Mas em geral começamos com condições iniciais com corrente zero, ou seja, <strong>i(t=0) = 0</strong>.</p>
<h4>Versão numérica com SciPy e Numpy</h4>
<p><em>Sim é muito Py. Pois este é poder do Python: Seus módulos! E as pessoas gostam de homenagear o Python colocando o Py no nome.</em></p>
<p>A solução numérica será encontrada utilizando o comando <code>solve_ivp</code> porém o correto agora é dizer "as soluções" pois o que obteremos é uma tabela (List) com os valores numéricos de <strong>i em t </strong>que utilizaremos para visualizarmos o gráfico do comportamento da corrente no circuito.</p>
<pre><code class="language-python">def circuito(t,i):
    return (5 -4700*i)/0.0001
    
tempo_maximo = 0.000001
t = np.linspace(0,tempo_maximo,1000)
sol = solve_ivp(circuito,[0,tempo_maximo],[0],method='RK45',t_eval=t)
plt.plot(sol.t,sol.y[0])
</code></pre>
<p>O <code>solve_ivp</code> precisa que a equação esteja no formato $${dy \over dt}= ...$$ que no nosso caso então seria $${di \over dt}= ...$$ e que esta equação esteja em forma de função Python. Definimos, então, <code>def circuito(t,i):</code>.</p>
<p>O primeiro parâmetro de <code>solve_ivp</code> é nossa função, o segundo o intervalo de tempo que a ODE será integrada e o [0] é o valor inicial e como foi dito antes a corrente no circuito inicialmente é zero, ou seja, [0].</p>
<p><strong>Tempo_maximo</strong> é crítico. Se um valor maior que o transitório do circuito for colocado não visualizaremos nada de útil, somente o estado estacionário do circuito. Se for muito pequeno veremos apenas o início do estado transitório que provavelmente será uma reta. Com esse valores o seguinte gráfico se apresenta:</p>
<figure class="post__image"><img loading="lazy"  src="https://fabiovila.github.io/media/posts/10/output_11_1.png" sizes="(max-width: 1024px) 100vw, 1024px" srcset="https://fabiovila.github.io/media/posts/10/responsive/output_11_1-xs.png 300w ,https://fabiovila.github.io/media/posts/10/responsive/output_11_1-sm.png 480w ,https://fabiovila.github.io/media/posts/10/responsive/output_11_1-md.png 768w ,https://fabiovila.github.io/media/posts/10/responsive/output_11_1-lg.png 1024w"  alt="" width="391" height="261"></figure>
<p>E finalmente algo visual. Como a fonte é contínua o gráfico se apresenta como o esperado. A corrente começa do zero e vai subindo gradativamente até que o indutor seja somente um curto-circuito e a corrente circulante seja a limitada pelo resistor.</p>
<h4>Fonte de tensão senoidal</h4>
<p>Um circuito de corrente contínua não nos oferece muito. Vamos então usar uma fonte de tensão de 1Khz com Vp de 5V.</p>
<h5>Solução analítica</h5>
<pre><code class="language-python">
S = 5*sin(t*(2*pi/(1/1000)))
R = 4700
L = 100e-6

t = Symbol('t')
v = Function('v')(t)
i = Function('i')(t)
    
eq = Eq(S,R*i+L*i.diff(t))
eq
dsolve(eq)
</code></pre>
<p>A única diferença é a mudança do <strong>S </strong>com a senoide provida pelo Seno do SymPy <code>sin</code>. As saídas serão então:</p>
<p>$\displaystyle 5 \sin{\left(2000 \pi t \right)} = 4700 i{\left(t \right)} + 0.0001 \frac{d}{d t} i{\left(t \right)}$</p>
<p>E a solução </p>
<p>$\displaystyle i{\left(t \right)} = C_{1} e^{- 47000000.0 t} + 0.00106382976822168 \sin{\left(2000 \pi t \right)} - 1.42217863170866 \cdot 10^{-7} \cos{\left(2000 \pi t \right)} $</p>
<p>Basicamente uma corrente não defasada com 1.06mA. Não entendi o outro cos de valor irrisório. Provavelmente o transitório inicial não seja uma composição pura do exponente e o sin, mas tenha algum componente que deforme a onda (Fourier).</p>
<h5>Solução numérica</h5>
<p>Na solução numérica faremos maiores alterações.</p>
<pre><code class="language-python">
def circuito(t,i):
    return (5*np.sin(t*(2*np.pi/0.0001)) -4700*i)/0.0001
    
tempo_maximo = 0.001
t = np.linspace(0,tempo_maximo,10000)
sol = solve_ivp(circuito,[0,tempo_maximo],[0],method='RK45',t_eval=t)
print(max(sol.y[0]),min(sol.y[0]))

plt.subplots(figsize=(15, 5))
plt.subplot(1, 2, 1)
plt.plot(sol.t,sol.y[0])
plt.subplot(1, 2, 2)
plt.plot(t,5*np.sin(t*(2*np.pi/0.0001)))
</code></pre>
<p>As alterações além da fonte foram o tempo que foi diminuído, exibimos o i máximo e mínimo</p>
<p class="msg msg--highlight ">0.0010661978534370956 -0.0010652848773317844</p>
<p>para conferência. Bem como plotamos dois gráficos. O primeiro com a corrente do circuito e o outro com a tensão da fonte exibidos abaixo.</p>
<figure class="post__image"><img loading="lazy"  src="https://fabiovila.github.io/media/posts/10/output_22_1.png" sizes="(max-width: 1024px) 100vw, 1024px" srcset="https://fabiovila.github.io/media/posts/10/responsive/output_22_1-xs.png 300w ,https://fabiovila.github.io/media/posts/10/responsive/output_22_1-sm.png 480w ,https://fabiovila.github.io/media/posts/10/responsive/output_22_1-md.png 768w ,https://fabiovila.github.io/media/posts/10/responsive/output_22_1-lg.png 1024w"  alt="" width="902" height="303"></figure>
<h4>Falstad</h4>
<p>Vamos conferir com o simulador de circuitos do <a href="#INTERNAL_LINK#/post/null" title="https://falstad.com/circuit/" target="_blank" rel="noopener noreferrer">Falstad</a>? Que aliás usa de muita solução numérica para simular o circuito.</p>
<figure class="post__image"><img loading="lazy"  src="https://fabiovila.github.io/media/posts/10/Captura-de-tela-de-2021-12-18-20-34-51.png" sizes="(max-width: 1024px) 100vw, 1024px" srcset="https://fabiovila.github.io/media/posts/10/responsive/Captura-de-tela-de-2021-12-18-20-34-51-xs.png 300w ,https://fabiovila.github.io/media/posts/10/responsive/Captura-de-tela-de-2021-12-18-20-34-51-sm.png 480w ,https://fabiovila.github.io/media/posts/10/responsive/Captura-de-tela-de-2021-12-18-20-34-51-md.png 768w ,https://fabiovila.github.io/media/posts/10/responsive/Captura-de-tela-de-2021-12-18-20-34-51-lg.png 1024w"  alt="" width="636" height="465"></figure>
<p>Como se pode ver no osciloscópio <strong>Fonte CA</strong> o <strong>Max=1.064mA</strong> bate com nossos cálculos.</p>
<p>Espero que tenham gostado. Em breve novos posts!</p>
<p> </p>
<p> </p>
            ]]>
        </content>
    </entry>
    <entry>
        <title>Usando Raspberry Pi como servidor syslog remoto para roteador Claro/NET</title>
        <author>
            <name>Fabio</name>
        </author>
        <link href="https://fabiovila.github.io/usando-raspberry-pi-como-servidor-syslog-remoto-para-roteador-claronet.html"/>
        <id>https://fabiovila.github.io/usando-raspberry-pi-como-servidor-syslog-remoto-para-roteador-claronet.html</id>
            <category term="segurança"/>
            <category term="rsyslog"/>
            <category term="raspberry-pi"/>

        <updated>2021-07-24T11:30:36-03:00</updated>
            <summary>
                <![CDATA[
                    Descobri esses dias que meu roteador Claro/NET tem a opção de log&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                <p>Descobri esses dias que meu roteador Claro/NET tem a opção de log remoto aproveitei então e configurei meu Raspberry PI como servidor remoto syslog do roteador. Neste artigo vou ensinar como colocar seu Raspberry PI e extensível a outras placas ou computadores rodando Linux como servidor syslog remoto e configurar o roteador Claro/NET para emitir logs para esse servidor.</p>
<h2>Configurando rsyslog</h2>
<p>O servidor syslog usado será o rsyslog que já vem por padrão instalado no Raspberry PI OS serão apenas criar e mudar alguns arquivos.</p>
<h2>Habilitando o servidor na porta 514 no RPI</h2>
<p>Para habilitar o servidor rsyslog na port 514 edite o arquivo<code> /etc/rsyslog.conf</code> e descomente as seguintes linhas:</p>
<pre><code># provides UDP syslog reception<br>module(load="imudp")<br>input(type="imudp" port="514")<br><br># provides TCP syslog reception<br>module(load="imtcp")<br>input(type="imtcp" port="514")</code></pre>
<h2>Criando o arquivo de log</h2>
<p>Você terá que especificar o arquivo e local que o log será acumulado, para isso crie o arquivo de log em /var/log com o nome desejado como no exemplo abaixo:</p>
<pre><code>$ sudo touch /var/log/claro.log</code></pre>
<h2>Configurando o rsyslog para seu arquivo de log</h2>
<p>Agora é hora de criar um arquivo com qualquer nome mas terminado em <code>.conf </code>no local <code>/etc/rsyslog.d/</code> que indicará no arquivo de log e o IP do cliente (o roteador) que produzirá os logs:</p>
<pre> <code class="language-shell" data-lang="shell">$template NetworkLog, "/var/log/claro.log"<br>:fromhost-ip, isequal, "192.168.0.1" -?NetworkLog<br>&amp; stop</code></pre>
<p>Veja que <code>"/var/log/claro.log"</code> deverá ser igual ao arquivo criado do passo anterior e o IP o IP do seu roteador.</p>
<h2>Rotate</h2>
<p>Não é uma boa deixar o log crescer indefinidamente, então é melhor configurar o rotate do arquivo impondo um limite. Crie um arquivo com qualquer nome em /etc/logrotate.d/ e coloque o texto abaixo:</p>
<pre><code class="language-shell" data-lang="shell">/var/log/claro.log { 
        rotate 7
        size 500k
        notifempty
        compress
        postrotate
                invoke-rc.d rsyslog rotate &gt; /dev/null
        endscript
    }</code></pre>
<h2>Reiniciando o rsyslog</h2>
<p>Finalmente reinicie o rsyslog:</p>
<pre><code class="language-shell" data-lang="shell">$ sudo service rsyslog restart</code></pre>
<h2>Configurando o Roteador Claro/NET</h2>
<p>Para configurar o roteador você deverá estar logado entrar em <strong>Configurações Avançadas </strong>e no Menu que aparecerá seguir o caminho <strong>Menu &gt; Segurança &gt; Firewall &gt; Log</strong> Remoto e a seguinte página será exibida:</p>
<figure class="post__image" ><img loading="lazy" src="https://fabiovila.github.io/media/posts/7/Captura-de-tela-de-2021-07-09-21-09-27.png" sizes="(max-width: 1024px) 100vw, 1024px" srcset="https://fabiovila.github.io/media/posts/7/responsive/Captura-de-tela-de-2021-07-09-21-09-27-xs.png 300w ,https://fabiovila.github.io/media/posts/7/responsive/Captura-de-tela-de-2021-07-09-21-09-27-sm.png 480w ,https://fabiovila.github.io/media/posts/7/responsive/Captura-de-tela-de-2021-07-09-21-09-27-md.png 768w ,https://fabiovila.github.io/media/posts/7/responsive/Captura-de-tela-de-2021-07-09-21-09-27-lg.png 1024w"  alt="Tela de configuração do roteador" width="876" height="1019">
<figcaption >Tela de configuração de LOG do roteador da Claro</figcaption>
</figure>
<p>No campo <strong>192.168.0.[   ]</strong> você deverá preencher com o final do IP do raspberry-pi rodando o rsyslog; escolher a opção "<strong>PARA SERVIDOR SYSLOG EM:</strong>" e finalmente nas opções de log desejadas.</p>
<p>A quantidade de logs produzidas é grande.</p>
<p> </p>
            ]]>
        </content>
    </entry>
    <entry>
        <title>Rede neural em python numpy para iris dataset</title>
        <author>
            <name>Fabio</name>
        </author>
        <link href="https://fabiovila.github.io/rede-neural-em-python-numpy-para-iris-dataset.html"/>
        <id>https://fabiovila.github.io/rede-neural-em-python-numpy-para-iris-dataset.html</id>
            <category term="redes-neurais"/>
            <category term="python"/>
            <category term="numpy"/>
            <category term="machine-learning"/>

        <updated>2021-06-02T14:23:31-03:00</updated>
            <summary>
                <![CDATA[
                        <img src="https://fabiovila.github.io/media/posts/6/Captura-de-tela-de-2021-06-02-14-23-17.png" alt="" />
                    O entendimento de como funciona o treinamento das redes neurais é um&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                    <img src="https://fabiovila.github.io/media/posts/6/Captura-de-tela-de-2021-06-02-14-23-17.png" alt="" />
                <p>O entendimento de como funciona o treinamento das redes neurais é um processo difícil por envolver conhecimentos de diversas áreas e matemática de nível superior. E mesmo para quem tem cálculo 1 e 2 quando se depara com a <em>derivação parcial do erro com base nos pesos</em> o entendimento não é trivial.</p>
<p>Ainda ficarei devendo essa explicação completa, mas enquanto isso segue este programa que fiz para python/numpy para treinar o dataset Iris usando duas camadas de redes neurais ativadas por sigmoide e treinadas usando retro-propagação com AdaGrad.</p>
<p>Sem o AdaGrad o treinamento se torna instável e pode ficar preso em um minimo local e nunca mais sair.</p>
<p>A convergência do Erro vai depender de cada execução devido a inicialização aleatória dos pesos, pode acontecer até mesmo de ainda sim ficar preso em um minimo local e não sair mais. Basta executar novamente que novos pesos aleatórios são inicializados.</p>
<p><a href="https://fabiovila.github.io/iris.data.csv" target="_blank" rel="noopener noreferrer" download>Link para download do iris dataset.</a></p>
<pre><code class="language-python">
import numpy as np

# Ativação sigmoid
def sig(n):
    return 1 / ( 1 + np.exp(-n))

# Derivada da sigmoid
# Muitos empacam aqui porque envolve cálculo 1 e 2 que só se aprende na faculdade
def dsig(n):
    return n * ( 1 - n)


if __name__ == '__main__':
    np.set_printoptions(precision=2 , suppress=True)

    # o iris.data.csv está organizado da seguinte forma:
    # 5.1,3.5,1.4,0.2,Iris-setosa
    # 4.9,3.0,1.4,0.2,Iris-setosa
    # 4.7,3.2,1.3,0.2,Iris-setosa
    #

    # carrega as quatro primeiras colunas que são os valores coletados na pesquisa
    X       = np.loadtxt('iris.data.csv', delimiter=',', usecols=[0,1,2,3])
    # carrega a última coluna contendo a string que define a categoria
    labels  = np.loadtxt('iris.data.csv', delimiter=',', dtype=str, usecols=[4])
    # Transforma as strings em valores númericos únicos
    l, Yu   = np.unique(labels, return_inverse=True)
    # e finalmente indexa cada valor numerico em um vetor 3 (ou matriz 1x3) 
    Y       = np.array([[0.0,0.0,1.0],[0.0,1.0,0.0],[1.0,0.0,0.0]])[Yu]
    
    r = np.random.randint(0,len(X),size=5)
    for rr in r:
        print ("X:" + str(X[rr]) + " Yu: " + str(Yu[rr]) + " Y: " + str(Y[rr]) + " Label: " + str(labels[rr]) )
    
    # logo os dados serão apresentados da seguinte forma para a rede neural
    # [5.1,3.5,1.4,0.2] - [1.0,0.0,0.0]


    # Dados armazenados, hora de montar a rede neural

    Wx = np.random.uniform(-5.0,5.0, size = (4,8))
    Bx = np.zeros((1,8))

    Wy = np.random.uniform(-5.0,5.0, size = (8,3))
    By = np.zeros((1,3))

    AWx = np.zeros((4,8))
    ABx = np.zeros((1,8))

    AWy = np.zeros((8,3))
    ABy = np.zeros((1,3))

    # faz uma breve previsão com a rede destreinada para observar os cálculos. O Forward
    ox =  sig(X[0] @ Wx + Bx)  # multiplicação de matrizes de X[0] com Wx e soma Bx o resultado é uma matrix e 1 linha e 8 colunas
    oy =  sig(ox @ Wy + By) 
    print(ox , oy)

    #let's cooking! vamos treinar a rede!
    lrate = 0.35
    for epoch in range(10000):
        # gera uma sequencia aleatória para ser usada como indice no próximo for
        # dessa forma os dados serão apresentados a rede de forma aleatória do que na sequência natural do arquivo
        Xr = np.random.permutation(len(X))
        et = 0  # erro total
        #lrate = lrate * 0.9999
        for ite in Xr:
            Xi = X[ite]
            Yi = Y[ite]



            ## o forward

            ox =  sig(Xi @ Wx + Bx)  # multiplicação de matrizes de X[0] com Wx e soma Bx o resultado é uma matrix e 1 linha e 8 colunas
            oy =  sig(ox @ Wy + By)


            ## o backward

            # o erro dessa interação
            e = oy - Yi 
            # a soma dos erros de todas a interações
            et += (e*e).sum()

            b = e * dsig(oy)
            delta = np.outer(ox,b)

            AWy += np.multiply(delta,delta)
            ABy += b*b

            Wy -= lrate * delta / np.sqrt(AWy + 1e-6)
            By -= lrate * b  / np.sqrt(ABy+1e-6)



            # propaga o erro para a camada x
            ex = e @ Wy.T

            # e finalmente atualiza a primeira camada
            b = ex * dsig(ox)
            delta = np.outer(Xi,b)

            AWx += np.multiply(delta,delta)
            ABx += b*b

            Wx -= lrate * delta / np.sqrt(AWx+1e-6)
            Bx -= lrate * b  / np.sqrt(ABx+1e-6)



        print ("Erro: %4.4f Learning Rate: %4.4f"%(et,lrate))
        #input()
            

    for n,xx in enumerate(X):
        ox =  sig(xx @ Wx + Bx)  
        oy =  sig(ox @ Wy + By)
        print ("X:" + str(xx) + " Y: " + str(Y[n]) + " Output: " + str(oy) )</code>  </pre>
            ]]>
        </content>
    </entry>
    <entry>
        <title>Fazendo uma dieta de café da manhã de baixo custo no OR-TOOLs</title>
        <author>
            <name>Fabio</name>
        </author>
        <link href="https://fabiovila.github.io/fazendo-um-cardapio-de-cafe-da-manha-com-calorias-e-baixo-custo-no-or-tools.html"/>
        <id>https://fabiovila.github.io/fazendo-um-cardapio-de-cafe-da-manha-com-calorias-e-baixo-custo-no-or-tools.html</id>
            <category term="python"/>
            <category term="otimização"/>
            <category term="cvxpy"/>

        <updated>2021-05-21T20:32:52-03:00</updated>
            <summary>
                <![CDATA[
                        <img src="https://fabiovila.github.io/media/posts/2/bread-18987_640.jpg" alt="" />
                    Dietas com restrições Um problema comum na nutrição é a confecção de&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                    <img src="https://fabiovila.github.io/media/posts/2/bread-18987_640.jpg" alt="" />
                <h2>Dietas com restrições</h2>
<p>Um problema comum na nutrição é a confecção de dietas com restrições. As restrições podem ser calóricas ou com ausência de algum componente como a lactose, a gordura, o glúten, etc ....</p>
<p>Em geral o custo destas dietas aumentam em relação a dieta comum. Para auxiliar na procura de uma dieta barata neste post faremos uma dieta abaixo de uma dada caloria e com menor custo possível usando o otimizador OR-TOOLs.</p>
<p><em>Apesar do título esse post (e meu blog) trata de um exemplo de uso do otimizador OR-TOOLs em Python e tem tópicos de matemática. Se você chegou aqui e é da área da nutrição provavelmente se perderá, porém ao menos ficará o conhecimento intuitivo do uso de softwares para se fazer dietas.</em></p>
<h6>Quantidades praticáveis</h6>
<p>O problema de escolher certos alimentos reduzindo o custo é um problema semelhante ao knapsack. Onde é dado uma lista de alimentos com seus valores calóricos e custos e uma quantidade de calorias máxima e minima que deverão ser respeitados. O objetivo é minimizar o custo da dieta. </p>
<p>Um dos problemas a se resolver é a quantidade impraticável. Não há como quantificar 1.01 ou 0.04 de um Ovo, a dieta deve conter quantidades praticáveis de cada alimento.</p>
<p>Há várias forma de se resolver isso. Uma delas é repetir o alimento com quantidades fracionadas e seguras. Dessa forma teremos $X_{?} - Ovo Inteiro, X_{?} - Meio Ovo$ e assim vai. É uma forma segura pois cada alimento tem fracionamento diferente como por exemplo o Leite que pode ser 1 Copo, 100mL, 1L, 0.1 Litros, 240mL em contraste com o Ovo que só faz sentido valores inteiros.</p>
<p>Entretanto um aumento no número de variáveis degrada a performance do solver. Mas não podemos esquecer que em um ambiente de produção a Nutricionista irá selecionar previamente os alimentos possíveis e ainda deve-se levar em conta que em um café da manhã não se tem muitas opções disponíveis o que torna o problema resolvível em tempo hábil.</p>
<p>Em um ambiente de produção quando a pessoa seleciona Ovo o programa automaticamente trabalha com Ovo inteiro e Meio Ovo. Para evitar que Meio Ovo seja usado mais de uma vez (o que daria um ovo inteiro) podemos restringir o Meio Ovo para somente 1 unidade, entretanto Ovo Inteiro pode ser usado indefinidamente unidades inteiras.</p>
<h6>O problema</h6>
<p>O modelo matemático deste problema é </p>
<div class="defin">
<p>Dados:</p>
<p>$V_{i}$ - Valor calórico do alimento $i$<br><br>$C_{i}$ - Custo em Reais do alimento $i$<br><br>$K$ - Calorias máximas da dieta</p>
<p>$Km$ - Calorias minimas da dieta</p>
<p>$X_{i}$ - Variável de decisão que indica a quantidade do alimento $i$ na dieta, não pode ser Reais pois podemos ter como resultado valores fracionários impraticáveis em alguns alimentos como ovos, pão, queijos.</p>
<p>$X_{i}\leq4$ - Limitamos o número de cada alimento para evitar monotonia da dieta</p>
<p>Onde queremos:</p>
<p>$\quad\min(\sum\nolimits_{X_{i}C_{i}})$</p>
<p>$\quad\text{sujeito a:}$</p>
<p>$\quad\sum\nolimits_{X_{i}V_{i}}\leq K$</p>
<p>$\quad\sum\nolimits_{X_{i}V_{i}}\geq Km$</p>
<p>$\quad X_{i}\in \{0, 0.5, 1, 1.5 , 2 , 2.5 , 3 , 3.5, 4\}$</p>
</div>
<p>$X_{i}$ deve ser maior ou igual a 0 e limitamos os valores para $\{0, 0.5, 1, 1.5 , 2 , 2.5 , 3 , 3.5, 4\}$ para impedir que um ovo tenha 1.01 ou 0.02 de quantidade e no máximo 4  quantidades do alimento para não sair uma dieta com poucos ou um alimento.</p>
<p> </p>
<p> </p>
<p> </p>
            ]]>
        </content>
    </entry>
    <entry>
        <title>O CVXPY para o problema de mochila (knapsack)</title>
        <author>
            <name>Fabio</name>
        </author>
        <link href="https://fabiovila.github.io/o-cvxpy-para-o-problema-de-mochila-knapsack.html"/>
        <id>https://fabiovila.github.io/o-cvxpy-para-o-problema-de-mochila-knapsack.html</id>
            <category term="python"/>
            <category term="otimização"/>
            <category term="cvxpy"/>

        <updated>2021-06-02T13:47:21-03:00</updated>
            <summary>
                <![CDATA[
                        <img src="https://fabiovila.github.io/media/posts/1/Screenshot-from-2021-05-15-17-39-07-2.png" alt="" />
                    CVXPY CVXPY é um framework python para diversos otimizadores com uma linguagem&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                    <img src="https://fabiovila.github.io/media/posts/1/Screenshot-from-2021-05-15-17-39-07-2.png" alt="" />
                <h2>CVXPY</h2>
<p>CVXPY é um framework python para diversos otimizadores com uma linguagem própria e suporte a Numpy.</p>
<p>Para instalar o CVXPY use o pip:</p>
<p><code class="language-bash">pip install cvxpy</code></p>
<p>Um dos otimizadores disponíveis é o <a href="https://projects.coin-or.org/Cbc" target="_blank" rel="noopener noreferrer">CBC</a>  um otimizador de programação linear inteiro open-source. O CBC pode ser usado em linha de comando sem ser necessário o CVXPY, mas neste caso será necessário aprender sua linguagem de entrada. </p>
<p>Também será necessário instalar o CVXOPT:</p>
<p><code class="language-bash">pip install cvxopt</code></p>
<h2>Problema da mochila</h2>
<p>O problema da mochila mais conhecido como knapsack é um problema clássico de otimização combinatória.</p>
<p>O problema consiste em colocar o maior valor possível de itens em uma mochila com certa capacidade de peso. A mochila tem uma capacidade definida de peso. Os itens um peso e um valor. A objetivo é ter o maior valor possível dentro da mochila, ou seja, maximizar o valor.</p>
<p>Esse problema aparece em diversas áreas como a logística, computação e investimentos.</p>
<pre><code class="language-python">import cvxpy as cp
import numpy as np
# Dados de entrada do problema
Valores = np.array([10,13,1,100,45,13,156,76,4,59,97,99])
Pesos = np.array([50,55,10,5,1,98,34,3,9,3,7,19])
Capacidade_Mochila = 100<br>
# Variaveis de decisão<br>
# Cada Item Xi terá valor 1 se estiver na mochila ou 0 se estiver fora
# cp.Variable cria uma variável no CVX ( não confunda cp com np ) do tipo boolean do tamanho da quantidade de itens
<br>Xi = cp.Variable((Valores.size), boolean = True)
<br># Constraints do problema<br>
# A soma total dos pesos dos itens escolhidos por Xi devem ser igual ou menor que a capacidade da mochila                
<br>constraints = [ Xi @ Pesos &lt;= Capacidade_Mochila ]
# Tambem pode ser escrito com o mesmo resultado como:
#constraints = [ cp.sum( cp.multiply (Xi, Pesos ) ) &lt;= Capacidade_Mochila ]
<br># O Objetivo do problema
# é maximizar os valores na mochila<br>
objective = cp.Maximize( Xi @ Valores )
<br># finalmente chamamos o solver com verbose para acompanhar 
# o progresso e a execução máxima de 1hr<br>
prob = cp.Problem(objective, constraints)              
prob.solve(solver=cp.CBC,verbose=True, maximumSeconds = 1 * 60 * 60)         
print("Status          : ", prob.status)
print("Valor encontrado: ", prob.value)
print("Valor de Xi     : ", Xi.value)
    </code></pre>
<p>O problema da mochila tem muitas aplicações práticas principalmente na logística. Imagine uma transportadora que precisa distribuir seus pacotes utilizando vans e caminhões. Cada pacote tem peso, tamanho, localidade, tempo de espera e valor. Um programa de otimização pode ajudar no preenchimento dos caminhões e em aplicações profissionais traçar a rota de distribuição de cada veículo.</p>
<p>Problemas de otimização não acham o melhor valor, porque em geral é uma tarefa impossível (o mais correto seria improvável) de acha-lo devido a explosão combinatória. Por isso são chamados 'otimizadores' porque eles buscam a melhor solução possível, ou seja, uma solução ótima.</p>
            ]]>
        </content>
    </entry>
</feed>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>Fabio</title>
    <link href="https://fabiovila.github.io/feed.xml" rel="self" />
    <link href="https://fabiovila.github.io" />
    <updated>2021-12-18T22:53:13-03:00</updated>
    <author>
        <name>Fabio</name>
    </author>
    <id>https://fabiovila.github.io</id>

    <entry>
        <title>Usando Python para solucionar ODE em circuitos elétricos: RL</title>
        <author>
            <name>Fabio</name>
        </author>
        <link href="https://fabiovila.github.io/usando-python-para-solucionar-ode-em-circuitos-eletricos.html"/>
        <id>https://fabiovila.github.io/usando-python-para-solucionar-ode-em-circuitos-eletricos.html</id>

        <updated>2021-12-18T22:53:13-03:00</updated>
            <summary>
                <![CDATA[
                    Neste primeiro post iniciarei uma série de posts tratando da solução de&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                <p>Neste primeiro post iniciarei uma série de posts tratando da solução de circuitos elétricos utilizando Python. Um bom início é o circuito RL pois encontramos nele apenas uma derivada.</p>
<figure class="post__image align-center"><img loading="lazy"  src="https://fabiovila.github.io/media/posts/10/circuit.png" sizes="(max-width: 1024px) 100vw, 1024px" srcset="https://fabiovila.github.io/media/posts/10/responsive/circuit-xs.png 300w ,https://fabiovila.github.io/media/posts/10/responsive/circuit-sm.png 480w ,https://fabiovila.github.io/media/posts/10/responsive/circuit-md.png 768w ,https://fabiovila.github.io/media/posts/10/responsive/circuit-lg.png 1024w"  alt="" width="260" height="180"></figure><br><br>Para uma fonte de 5V o circuito é modelado pela seguinte equação diferencial</p>
<p class="msg msg--highlight ">$\displaystyle 5 = 4700 i{\left(t \right)} + 0.0001 \frac{d}{d t} i{\left(t \right)}$</p>
<p> </p>
<p>Posteriormente iremos usar uma fonte CA senoidal.</p>
<p>Conhecidas como Equações Diferenciais Ordinárias ou abreviadamente ODE essas equações podem ter soluções analítica ou numérica. A solução analítica é a solução como conhecemos na escola ou a simples solução algébrica através de manipulação dos símbolos. Entretanto a solução analítica de uma ODE requer conhecimento de cálculo 2 lecionado no nível superior. </p>
<p>A solução numérica não manipula símbolos, utiliza-se de métodos interativos com tentativa e erros com um certo discernimento de para onde ir em busca da solução. </p>
<p>Veremos neste post os dois métodos utilizando Python. Primeiro faremos alguns imports.</p>
<pre><code class="language-python">
from sympy import *
import numpy as np
from scipy.integrate import solve_ivp
import matplotlib.pyplot as plt
%matplotlib inline
</code></pre>
<h4>Versão analítica com SymPy</h4>
<p>A solução analítica pode ser encontrada utilizando o módulo Sympy. É um módulo promissor, mas ainda está em um nível intermediário de maturidade. Não se compara em poder ao Maxima e o Mathematica.</p>
<p>A solução analítica de uma ODE utilizando o Sympy é encontrada com o comando <code>dsolve</code>.</p>
<pre><code class="language-python">
S = 5
R = 4700
L = 100e-6

t = Symbol('t')
v = Function('v')(t)
i = Function('i')(t)
    
eq = Eq(S,R*i+L*i.diff(t))
eq
</code></pre>
<p>O Sympy exibe em formato tex a equação acima como:</p>
<p class="msg msg--highlight ">$\displaystyle 5 = 4700 i{\left(t \right)} + 0.0001 \frac{d}{d t} i{\left(t \right)}$</p>
<p>E como dito a solução analítica é encontrada pelo comando <code>dsolve</code>: </p>
<pre><code class="language-python">dsolve(eq)
</code></pre>
<p>cuja saída será:</p>
<p class="msg msg--highlight ">$\displaystyle i{\left(t \right)} = C_{1} e^{- 47000000.0 t} + \frac{1}{940}$</p>
<p>Que é a função de <strong>i em t </strong>como desejamos. C_1 é uma constante que como toda equação diferencial e sistemas físicos que armazenam energia essa constante define a condição inicial da função, oras, temos um indutor no circuito que INICIALMENTE pode ter um campo magnético de valor 0 ou qualquer outro valor que iria interferir no início do circuito. Cabe a nós dizer qual é esse campo. Mas em geral começamos com condições iniciais com corrente zero, ou seja, <strong>i(t=0) = 0</strong>.</p>
<h4>Versão numérica com SciPy e Numpy</h4>
<p><em>Sim é muito Py. Pois este é poder do Python: Seus módulos! E as pessoas gostam de homenagear o Python colocando o Py no nome.</em></p>
<p>A solução numérica será encontrada utilizando o comando <code>solve_ivp</code> porém o correto agora é dizer "as soluções" pois o que obteremos é uma tabela (List) com os valores numéricos de <strong>i em t </strong>que utilizaremos para visualizarmos o gráfico do comportamento da corrente no circuito.</p>
<pre><code class="language-python">def circuito(t,i):
    return (5 -4700*i)/0.0001
    
tempo_maximo = 0.000001
t = np.linspace(0,tempo_maximo,1000)
sol = solve_ivp(circuito,[0,tempo_maximo],[0],method='RK45',t_eval=t)
plt.plot(sol.t,sol.y[0])
</code></pre>
<p>O <code>solve_ivp</code> precisa que a equação esteja no formato $${dy \over dt}= ...$$ que no nosso caso então seria $${di \over dt}= ...$$ e que esta equação esteja em forma de função Python. Definimos, então, <code>def circuito(t,i):</code>.</p>
<p>O primeiro parâmetro de <code>solve_ivp</code> é nossa função, o segundo o intervalo de tempo que a ODE será integrada e o [0] é o valor inicial e como foi dito antes a corrente no circuito inicialmente é zero, ou seja, [0].</p>
<p><strong>Tempo_maximo</strong> é crítico. Se um valor maior que o transitório do circuito for colocado não visualizaremos nada de útil, somente o estado estacionário do circuito. Se for muito pequeno veremos apenas o início do estado transitório que provavelmente será uma reta. Com esse valores o seguinte gráfico se apresenta:</p>
<figure class="post__image"><img loading="lazy"  src="https://fabiovila.github.io/media/posts/10/output_11_1.png" sizes="(max-width: 1024px) 100vw, 1024px" srcset="https://fabiovila.github.io/media/posts/10/responsive/output_11_1-xs.png 300w ,https://fabiovila.github.io/media/posts/10/responsive/output_11_1-sm.png 480w ,https://fabiovila.github.io/media/posts/10/responsive/output_11_1-md.png 768w ,https://fabiovila.github.io/media/posts/10/responsive/output_11_1-lg.png 1024w"  alt="" width="391" height="261"></figure>
<p>E finalmente algo visual. Como a fonte é contínua o gráfico se apresenta como o esperado. A corrente começa do zero e vai subindo gradativamente até que o indutor seja somente um curto-circuito e a corrente circulante seja a limitada pelo resistor.</p>
<h4>Fonte de tensão senoidal</h4>
<p>Um circuito de corrente contínua não nos oferece muito. Vamos então usar uma fonte de tensão de 1Khz com Vp de 5V.</p>
<h5>Solução analítica</h5>
<pre><code class="language-python">
S = 5*sin(t*(2*pi/(1/1000)))
R = 4700
L = 100e-6

t = Symbol('t')
v = Function('v')(t)
i = Function('i')(t)
    
eq = Eq(S,R*i+L*i.diff(t))
eq
dsolve(eq)
</code></pre>
<p>A única diferença é a mudança do <strong>S </strong>com a senoide provida pelo Seno do SymPy <code>sin</code>. As saídas serão então:</p>
<p>$\displaystyle 5 \sin{\left(2000 \pi t \right)} = 4700 i{\left(t \right)} + 0.0001 \frac{d}{d t} i{\left(t \right)}$</p>
<p>E a solução </p>
<p>$\displaystyle i{\left(t \right)} = C_{1} e^{- 47000000.0 t} + 0.00106382976822168 \sin{\left(2000 \pi t \right)} - 1.42217863170866 \cdot 10^{-7} \cos{\left(2000 \pi t \right)} $</p>
<p>Basicamente uma corrente não defasada com 1.06mA. Não entendi o outro cos de valor irrisório. Provavelmente o transitório inicial não seja uma composição pura do exponente e o sin, mas tenha algum componente que deforme a onda (Fourier).</p>
<h5>Solução numérica</h5>
<p>Na solução numérica faremos maiores alterações.</p>
<pre><code class="language-python">
def circuito(t,i):
    return (5*np.sin(t*(2*np.pi/0.0001)) -4700*i)/0.0001
    
tempo_maximo = 0.001
t = np.linspace(0,tempo_maximo,10000)
sol = solve_ivp(circuito,[0,tempo_maximo],[0],method='RK45',t_eval=t)
print(max(sol.y[0]),min(sol.y[0]))

plt.subplots(figsize=(15, 5))
plt.subplot(1, 2, 1)
plt.plot(sol.t,sol.y[0])
plt.subplot(1, 2, 2)
plt.plot(t,5*np.sin(t*(2*np.pi/0.0001)))
</code></pre>
<p>As alterações além da fonte foram o tempo que foi diminuído, exibimos o i máximo e mínimo</p>
<p class="msg msg--highlight ">0.0010661978534370956 -0.0010652848773317844</p>
<p>para conferência. Bem como plotamos dois gráficos. O primeiro com a corrente do circuito e o outro com a tensão da fonte exibidos abaixo.</p>
<figure class="post__image"><img loading="lazy"  src="https://fabiovila.github.io/media/posts/10/output_22_1.png" sizes="(max-width: 1024px) 100vw, 1024px" srcset="https://fabiovila.github.io/media/posts/10/responsive/output_22_1-xs.png 300w ,https://fabiovila.github.io/media/posts/10/responsive/output_22_1-sm.png 480w ,https://fabiovila.github.io/media/posts/10/responsive/output_22_1-md.png 768w ,https://fabiovila.github.io/media/posts/10/responsive/output_22_1-lg.png 1024w"  alt="" width="902" height="303"></figure>
<h4>Falstad</h4>
<p>Vamos conferir com o simulador de circuitos do <a href="#INTERNAL_LINK#/post/null" title="https://falstad.com/circuit/" target="_blank" rel="noopener noreferrer">Falstad</a>? Que aliás usa de muita solução numérica para simular o circuito.</p>
<figure class="post__image"><img loading="lazy"  src="https://fabiovila.github.io/media/posts/10/Captura-de-tela-de-2021-12-18-20-34-51.png" sizes="(max-width: 1024px) 100vw, 1024px" srcset="https://fabiovila.github.io/media/posts/10/responsive/Captura-de-tela-de-2021-12-18-20-34-51-xs.png 300w ,https://fabiovila.github.io/media/posts/10/responsive/Captura-de-tela-de-2021-12-18-20-34-51-sm.png 480w ,https://fabiovila.github.io/media/posts/10/responsive/Captura-de-tela-de-2021-12-18-20-34-51-md.png 768w ,https://fabiovila.github.io/media/posts/10/responsive/Captura-de-tela-de-2021-12-18-20-34-51-lg.png 1024w"  alt="" width="636" height="465"></figure>
<p>Como se pode ver no osciloscópio <strong>Fonte CA</strong> o <strong>Max=1.064mA</strong> bate com nossos cálculos.</p>
<p>Espero que tenham gostado. Em breve novos posts!</p>
<p> </p>
<p> </p>
            ]]>
        </content>
    </entry>
    <entry>
        <title>Lista com 1000000 de números e seus fatores primos e se são primos ou quadrados perfeitos</title>
        <author>
            <name>Fabio</name>
        </author>
        <link href="https://fabiovila.github.io/lista-com-1000000-de-numeros-e-seus-fatores-primos-e-se-sao-primos-ou-quadrados-perfeitos.html"/>
        <id>https://fabiovila.github.io/lista-com-1000000-de-numeros-e-seus-fatores-primos-e-se-sao-primos-ou-quadrados-perfeitos.html</id>

        <updated>2021-10-09T15:22:28-03:00</updated>
            <summary>
                <![CDATA[
                    Segue uma lista que fiz para um CAS que estou programando contendo&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                <p>Segue uma lista que fiz para um CAS que estou programando contendo 1000000 de números no formato csv com a seguinte forma:</p>
<p>Número em si</p>
<p>Se primo = 1 se não = 0</p>
<p>Até 23 Fatores primos separados por vírgula. Os números primos tem como fator eles próprios</p>
<p>Se for um quadrado perfeito indica a raiz desse quadrado</p>
<p>Exemplos:</p>
<pre>9,0,3,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3<br>9999999,0,4649,239,3,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0</pre>
<p> </p>
<p> </p>
            ]]>
        </content>
    </entry>
    <entry>
        <title>Probabilidade Clássica, frequentista e subjetiva</title>
        <author>
            <name>Fabio</name>
        </author>
        <link href="https://fabiovila.github.io/probabilidade-classica-frequentista-e-subjetiva.html"/>
        <id>https://fabiovila.github.io/probabilidade-classica-frequentista-e-subjetiva.html</id>

        <updated>2021-08-09T21:22:53-03:00</updated>
            <summary>
                <![CDATA[
                        <img src="https://fabiovila.github.io/media/posts/8/royal-flush-playing-card-and-casino-chips-on-green-poker-background.jpg" alt="https://br.freepik.com/fotos/fundo" />
                    Probabilidade Transformando idéias e sensações em números O mundo não é determinístico&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                    <img src="https://fabiovila.github.io/media/posts/8/royal-flush-playing-card-and-casino-chips-on-green-poker-background.jpg" alt="https://br.freepik.com/fotos/fundo" />
                <h2>Probabilidade</h2>
<p><em>Transformando idéias e sensações em números</em></p>
<p>O mundo não é <strong>determinístico</strong> para <em>nós.</em> Não temos as fórmulas, regras, leis, ou a onisciência de <em>determinar</em> (no sentido de precisar) quando, quanto e se a coisas acontecerão no futuro; entretanto com o avanço da matemática ao longo da história, transformar idéias e conceitos em números foi se tornando algo útil e essa quantificação das idéias chegou nas 'possibilidades' para nos ajudar a <em>prever</em> esse futuro desconhecido. Independente da matemática já percebemos que alguns eventos são mais <strong>prováveis</strong> de ocorrer que outros; sabemos naturalmente que em céu nublado é mais provável de chover do que em um céu limpo.</p>
<p>Mas foi nos jogos e na busca pelo dinheiro fácil que a matemática de tentar prever o futuro avançou e tornou-se o que conhecemos hoje como <strong>probabilidade.</strong> Era preciso um número fixo e preciso, um valor que mostrasse o quanto uma aposta era mais provável de ganhar que perder, já não bastava apostar um bom dinheiro apenas em sensações vagas como "essa jogada tem altas chances de ganhar". Era necessário mais precisão.</p>
<p>Os jogos em geral são sistemas fáceis de se lidar matematicamente, são poucas as variáveis com seus valores ali presentes e prontos para os cálculos. Um dado lançado só tem 6 possíveis valores a mostrar, uma carta tirada de um baralho completo só pode ser umas das 52 cartas possíveis. Uma moeda só tem dois lados, dessa forma só dois resultados são possíveis. Chamamos esses resultados de <strong>eventos </strong>de um <strong>experimento. </strong>Jogar um dado e anotar a face de cima é um experimento, o valor da face é o evento.</p>
<p>Imagine que sua chance de ficar rico seja o lançar de um dado de 6 lados. Se você acertar o número que aparecerá na face de cima após um lançamento você ficará rico. Se o dado tem 6 lados então temos 5 possibilidades de perder e somente 1 possibilidade de ganhar. E se for um dado de 20 lados? Agora são 19 para 1 a possibilidade de perder. E se lhe fosse permitido escolher 5 números no dado de 6? Então neste caso você teria 5 chances de ganhar e 1 de perder. Seria muito azar não ficar rico.</p>
<p class="destaque">Não confunda as chances e possibilidades com tentativas. Há apenas uma tentativa aqui ou experimento. Perdeu no primeiro lançamento, acabou o sonho.</p>
<p>Se for uma moeda você já abre o champanhe antes mesmo de lançar. Se for na Mega Sena você não dá bola, pois sabe que vai perder.</p>
<p>Na probabilidade clássica considera-se que os eventos tem a <strong>mesma</strong> probabilidade de ocorrerem ou chances iguais. De fato se você pensar no lançamento do dado a chance de cair qualquer número é igual para todos. É o mesmo caso do lançamento da moeda no cara e coroa ou na retirada do baralho.</p>
<p>Sabendo da quantidade dos eventos possíveis de ocorrer fica fácil calcular um <strong>número</strong> que nos indique a chance de um evento ocorrer, a chance de ficar rico ou não, de desistir ou continuar. E ficou claro nos exemplos acima de que quanto maior a quantidade de eventos possíveis menores suas chances de vencer e quanto maior a quantidade dos eventos vencedores maiores suas chances de vencer. Que operação matemática com dois números tem esse comportamento? </p>
<p>Chamamos de <strong>espaço amostral  </strong>o conjunto de todos os resultados possíveis do experimento. Seja um <em>experimento de lançar um dado de 6 lados</em> o espaço amostral denotado de S ou U (universo) desse experimento é $S=\{1,2,3,4,5,6\} do <em>lançamento de uma moeda</em> o espaço amostral é $S=\{ cara, coroa \}$.</p>
<p>A probabilidade de ocorrer um evento $A$ do espaço amostral é dado por:</p>
<p>\[P(A)=\frac{\text{Número de vezes que A ocorre}}{\text{Número total de elementos no espaço amostral}}\]</p>
<p>No experimento de jogar um dado e cair o número 5 a probabilidade é:</p>
<p>$S=\{1,2,3,4,5,6\}\quad\text{Número total de elementos}=6$</p>
<p>$A=5\quad\text{Número de vezes que A ocorre}=1$</p>
<p>$\color{blue}P(A)=\frac{1}{6}=0.1666...$</p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
            ]]>
        </content>
    </entry>
    <entry>
        <title>Usando Raspberry Pi como servidor syslog remoto para roteador Claro/NET</title>
        <author>
            <name>Fabio</name>
        </author>
        <link href="https://fabiovila.github.io/usando-raspberry-pi-como-servidor-syslog-remoto-para-roteador-claronet.html"/>
        <id>https://fabiovila.github.io/usando-raspberry-pi-como-servidor-syslog-remoto-para-roteador-claronet.html</id>
            <category term="segurança"/>
            <category term="rsyslog"/>
            <category term="raspberry-pi"/>

        <updated>2021-07-24T11:30:36-03:00</updated>
            <summary>
                <![CDATA[
                    Descobri esses dias que meu roteador Claro/NET tem a opção de log&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                <p>Descobri esses dias que meu roteador Claro/NET tem a opção de log remoto aproveitei então e configurei meu Raspberry PI como servidor remoto syslog do roteador. Neste artigo vou ensinar como colocar seu Raspberry PI e extensível a outras placas ou computadores rodando Linux como servidor syslog remoto e configurar o roteador Claro/NET para emitir logs para esse servidor.</p>
<h2>Configurando rsyslog</h2>
<p>O servidor syslog usado será o rsyslog que já vem por padrão instalado no Raspberry PI OS serão apenas criar e mudar alguns arquivos.</p>
<h2>Habilitando o servidor na porta 514 no RPI</h2>
<p>Para habilitar o servidor rsyslog na port 514 edite o arquivo<code> /etc/rsyslog.conf</code> e descomente as seguintes linhas:</p>
<pre><code># provides UDP syslog reception<br>module(load="imudp")<br>input(type="imudp" port="514")<br><br># provides TCP syslog reception<br>module(load="imtcp")<br>input(type="imtcp" port="514")</code></pre>
<h2>Criando o arquivo de log</h2>
<p>Você terá que especificar o arquivo e local que o log será acumulado, para isso crie o arquivo de log em /var/log com o nome desejado como no exemplo abaixo:</p>
<pre><code>$ sudo touch /var/log/claro.log</code></pre>
<h2>Configurando o rsyslog para seu arquivo de log</h2>
<p>Agora é hora de criar um arquivo com qualquer nome mas terminado em <code>.conf </code>no local <code>/etc/rsyslog.d/</code> que indicará no arquivo de log e o IP do cliente (o roteador) que produzirá os logs:</p>
<pre> <code class="language-shell" data-lang="shell">$template NetworkLog, "/var/log/claro.log"<br>:fromhost-ip, isequal, "192.168.0.1" -?NetworkLog<br>&amp; stop</code></pre>
<p>Veja que <code>"/var/log/claro.log"</code> deverá ser igual ao arquivo criado do passo anterior e o IP o IP do seu roteador.</p>
<h2>Rotate</h2>
<p>Não é uma boa deixar o log crescer indefinidamente, então é melhor configurar o rotate do arquivo impondo um limite. Crie um arquivo com qualquer nome em /etc/logrotate.d/ e coloque o texto abaixo:</p>
<pre><code class="language-shell" data-lang="shell">/var/log/claro.log { 
        rotate 7
        size 500k
        notifempty
        compress
        postrotate
                invoke-rc.d rsyslog rotate &gt; /dev/null
        endscript
    }</code></pre>
<h2>Reiniciando o rsyslog</h2>
<p>Finalmente reinicie o rsyslog:</p>
<pre><code class="language-shell" data-lang="shell">$ sudo service rsyslog restart</code></pre>
<h2>Configurando o Roteador Claro/NET</h2>
<p>Para configurar o roteador você deverá estar logado entrar em <strong>Configurações Avançadas </strong>e no Menu que aparecerá seguir o caminho <strong>Menu &gt; Segurança &gt; Firewall &gt; Log</strong> Remoto e a seguinte página será exibida:</p>
<figure class="post__image" ><img loading="lazy" src="https://fabiovila.github.io/media/posts/7/Captura-de-tela-de-2021-07-09-21-09-27.png" sizes="(max-width: 1024px) 100vw, 1024px" srcset="https://fabiovila.github.io/media/posts/7/responsive/Captura-de-tela-de-2021-07-09-21-09-27-xs.png 300w ,https://fabiovila.github.io/media/posts/7/responsive/Captura-de-tela-de-2021-07-09-21-09-27-sm.png 480w ,https://fabiovila.github.io/media/posts/7/responsive/Captura-de-tela-de-2021-07-09-21-09-27-md.png 768w ,https://fabiovila.github.io/media/posts/7/responsive/Captura-de-tela-de-2021-07-09-21-09-27-lg.png 1024w"  alt="Tela de configuração do roteador" width="876" height="1019">
<figcaption >Tela de configuração de LOG do roteador da Claro</figcaption>
</figure>
<p>No campo <strong>192.168.0.[   ]</strong> você deverá preencher com o final do IP do raspberry-pi rodando o rsyslog; escolher a opção "<strong>PARA SERVIDOR SYSLOG EM:</strong>" e finalmente nas opções de log desejadas.</p>
<p>A quantidade de logs produzidas é grande.</p>
<p> </p>
            ]]>
        </content>
    </entry>
    <entry>
        <title>Rede neural em python numpy para iris dataset</title>
        <author>
            <name>Fabio</name>
        </author>
        <link href="https://fabiovila.github.io/rede-neural-em-python-numpy-para-iris-dataset.html"/>
        <id>https://fabiovila.github.io/rede-neural-em-python-numpy-para-iris-dataset.html</id>
            <category term="redes-neurais"/>
            <category term="python"/>
            <category term="numpy"/>
            <category term="machine-learning"/>

        <updated>2021-06-02T14:23:31-03:00</updated>
            <summary>
                <![CDATA[
                        <img src="https://fabiovila.github.io/media/posts/6/Captura-de-tela-de-2021-06-02-14-23-17.png" alt="" />
                    O entendimento de como funciona o treinamento das redes neurais é um&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                    <img src="https://fabiovila.github.io/media/posts/6/Captura-de-tela-de-2021-06-02-14-23-17.png" alt="" />
                <p>O entendimento de como funciona o treinamento das redes neurais é um processo difícil por envolver conhecimentos de diversas áreas e matemática de nível superior. E mesmo para quem tem cálculo 1 e 2 quando se depara com a <em>derivação parcial do erro com base nos pesos</em> o entendimento não é trivial.</p>
<p>Ainda ficarei devendo essa explicação completa, mas enquanto isso segue este programa que fiz para python/numpy para treinar o dataset Iris usando duas camadas de redes neurais ativadas por sigmoide e treinadas usando retro-propagação com AdaGrad.</p>
<p>Sem o AdaGrad o treinamento se torna instável e pode ficar preso em um minimo local e nunca mais sair.</p>
<p>A convergência do Erro vai depender de cada execução devido a inicialização aleatória dos pesos, pode acontecer até mesmo de ainda sim ficar preso em um minimo local e não sair mais. Basta executar novamente que novos pesos aleatórios são inicializados.</p>
<p><a href="https://fabiovila.github.io/iris.data.csv" target="_blank" rel="noopener noreferrer" download>Link para download do iris dataset.</a></p>
<pre><code class="language-python">
import numpy as np

# Ativação sigmoid
def sig(n):
    return 1 / ( 1 + np.exp(-n))

# Derivada da sigmoid
# Muitos empacam aqui porque envolve cálculo 1 e 2 que só se aprende na faculdade
def dsig(n):
    return n * ( 1 - n)


if __name__ == '__main__':
    np.set_printoptions(precision=2 , suppress=True)

    # o iris.data.csv está organizado da seguinte forma:
    # 5.1,3.5,1.4,0.2,Iris-setosa
    # 4.9,3.0,1.4,0.2,Iris-setosa
    # 4.7,3.2,1.3,0.2,Iris-setosa
    #

    # carrega as quatro primeiras colunas que são os valores coletados na pesquisa
    X       = np.loadtxt('iris.data.csv', delimiter=',', usecols=[0,1,2,3])
    # carrega a última coluna contendo a string que define a categoria
    labels  = np.loadtxt('iris.data.csv', delimiter=',', dtype=str, usecols=[4])
    # Transforma as strings em valores númericos únicos
    l, Yu   = np.unique(labels, return_inverse=True)
    # e finalmente indexa cada valor numerico em um vetor 3 (ou matriz 1x3) 
    Y       = np.array([[0.0,0.0,1.0],[0.0,1.0,0.0],[1.0,0.0,0.0]])[Yu]
    
    r = np.random.randint(0,len(X),size=5)
    for rr in r:
        print ("X:" + str(X[rr]) + " Yu: " + str(Yu[rr]) + " Y: " + str(Y[rr]) + " Label: " + str(labels[rr]) )
    
    # logo os dados serão apresentados da seguinte forma para a rede neural
    # [5.1,3.5,1.4,0.2] - [1.0,0.0,0.0]


    # Dados armazenados, hora de montar a rede neural

    Wx = np.random.uniform(-5.0,5.0, size = (4,8))
    Bx = np.zeros((1,8))

    Wy = np.random.uniform(-5.0,5.0, size = (8,3))
    By = np.zeros((1,3))

    AWx = np.zeros((4,8))
    ABx = np.zeros((1,8))

    AWy = np.zeros((8,3))
    ABy = np.zeros((1,3))

    # faz uma breve previsão com a rede destreinada para observar os cálculos. O Forward
    ox =  sig(X[0] @ Wx + Bx)  # multiplicação de matrizes de X[0] com Wx e soma Bx o resultado é uma matrix e 1 linha e 8 colunas
    oy =  sig(ox @ Wy + By) 
    print(ox , oy)

    #let's cooking! vamos treinar a rede!
    lrate = 0.35
    for epoch in range(10000):
        # gera uma sequencia aleatória para ser usada como indice no próximo for
        # dessa forma os dados serão apresentados a rede de forma aleatória do que na sequência natural do arquivo
        Xr = np.random.permutation(len(X))
        et = 0  # erro total
        #lrate = lrate * 0.9999
        for ite in Xr:
            Xi = X[ite]
            Yi = Y[ite]



            ## o forward

            ox =  sig(Xi @ Wx + Bx)  # multiplicação de matrizes de X[0] com Wx e soma Bx o resultado é uma matrix e 1 linha e 8 colunas
            oy =  sig(ox @ Wy + By)


            ## o backward

            # o erro dessa interação
            e = oy - Yi 
            # a soma dos erros de todas a interações
            et += (e*e).sum()

            b = e * dsig(oy)
            delta = np.outer(ox,b)

            AWy += np.multiply(delta,delta)
            ABy += b*b

            Wy -= lrate * delta / np.sqrt(AWy + 1e-6)
            By -= lrate * b  / np.sqrt(ABy+1e-6)



            # propaga o erro para a camada x
            ex = e @ Wy.T

            # e finalmente atualiza a primeira camada
            b = ex * dsig(ox)
            delta = np.outer(Xi,b)

            AWx += np.multiply(delta,delta)
            ABx += b*b

            Wx -= lrate * delta / np.sqrt(AWx+1e-6)
            Bx -= lrate * b  / np.sqrt(ABx+1e-6)



        print ("Erro: %4.4f Learning Rate: %4.4f"%(et,lrate))
        #input()
            

    for n,xx in enumerate(X):
        ox =  sig(xx @ Wx + Bx)  
        oy =  sig(ox @ Wy + By)
        print ("X:" + str(xx) + " Y: " + str(Y[n]) + " Output: " + str(oy) )</code>  </pre>
            ]]>
        </content>
    </entry>
    <entry>
        <title>Fazendo uma dieta de café da manhã de baixo custo no OR-TOOLs</title>
        <author>
            <name>Fabio</name>
        </author>
        <link href="https://fabiovila.github.io/fazendo-um-cardapio-de-cafe-da-manha-com-calorias-e-baixo-custo-no-or-tools.html"/>
        <id>https://fabiovila.github.io/fazendo-um-cardapio-de-cafe-da-manha-com-calorias-e-baixo-custo-no-or-tools.html</id>
            <category term="python"/>
            <category term="otimização"/>
            <category term="cvxpy"/>

        <updated>2021-05-21T20:32:52-03:00</updated>
            <summary>
                <![CDATA[
                        <img src="https://fabiovila.github.io/media/posts/2/bread-18987_640.jpg" alt="" />
                    Dietas com restrições Um problema comum na nutrição é a confecção de&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                    <img src="https://fabiovila.github.io/media/posts/2/bread-18987_640.jpg" alt="" />
                <h2>Dietas com restrições</h2>
<p>Um problema comum na nutrição é a confecção de dietas com restrições. As restrições podem ser calóricas ou com ausência de algum componente como a lactose, a gordura, o glúten, etc ....</p>
<p>Em geral o custo destas dietas aumentam em relação a dieta comum. Para auxiliar na procura de uma dieta barata neste post faremos uma dieta abaixo de uma dada caloria e com menor custo possível usando o otimizador OR-TOOLs.</p>
<p><em>Apesar do título esse post (e meu blog) trata de um exemplo de uso do otimizador OR-TOOLs em Python e tem tópicos de matemática. Se você chegou aqui e é da área da nutrição provavelmente se perderá, porém ao menos ficará o conhecimento intuitivo do uso de softwares para se fazer dietas.</em></p>
<h6>Quantidades praticáveis</h6>
<p>O problema de escolher certos alimentos reduzindo o custo é um problema semelhante ao knapsack. Onde é dado uma lista de alimentos com seus valores calóricos e custos e uma quantidade de calorias máxima e minima que deverão ser respeitados. O objetivo é minimizar o custo da dieta. </p>
<p>Um dos problemas a se resolver é a quantidade impraticável. Não há como quantificar 1.01 ou 0.04 de um Ovo, a dieta deve conter quantidades praticáveis de cada alimento.</p>
<p>Há várias forma de se resolver isso. Uma delas é repetir o alimento com quantidades fracionadas e seguras. Dessa forma teremos $X_{?} - Ovo Inteiro, X_{?} - Meio Ovo$ e assim vai. É uma forma segura pois cada alimento tem fracionamento diferente como por exemplo o Leite que pode ser 1 Copo, 100mL, 1L, 0.1 Litros, 240mL em contraste com o Ovo que só faz sentido valores inteiros.</p>
<p>Entretanto um aumento no número de variáveis degrada a performance do solver. Mas não podemos esquecer que em um ambiente de produção a Nutricionista irá selecionar previamente os alimentos possíveis e ainda deve-se levar em conta que em um café da manhã não se tem muitas opções disponíveis o que torna o problema resolvível em tempo hábil.</p>
<p>Em um ambiente de produção quando a pessoa seleciona Ovo o programa automaticamente trabalha com Ovo inteiro e Meio Ovo. Para evitar que Meio Ovo seja usado mais de uma vez (o que daria um ovo inteiro) podemos restringir o Meio Ovo para somente 1 unidade, entretanto Ovo Inteiro pode ser usado indefinidamente unidades inteiras.</p>
<h6>O problema</h6>
<p>O modelo matemático deste problema é </p>
<div class="defin">
<p>Dados:</p>
<p>$V_{i}$ - Valor calórico do alimento $i$<br><br>$C_{i}$ - Custo em Reais do alimento $i$<br><br>$K$ - Calorias máximas da dieta</p>
<p>$Km$ - Calorias minimas da dieta</p>
<p>$X_{i}$ - Variável de decisão que indica a quantidade do alimento $i$ na dieta, não pode ser Reais pois podemos ter como resultado valores fracionários impraticáveis em alguns alimentos como ovos, pão, queijos.</p>
<p>$X_{i}\leq4$ - Limitamos o número de cada alimento para evitar monotonia da dieta</p>
<p>Onde queremos:</p>
<p>$\quad\min(\sum\nolimits_{X_{i}C_{i}})$</p>
<p>$\quad\text{sujeito a:}$</p>
<p>$\quad\sum\nolimits_{X_{i}V_{i}}\leq K$</p>
<p>$\quad\sum\nolimits_{X_{i}V_{i}}\geq Km$</p>
<p>$\quad X_{i}\in \{0, 0.5, 1, 1.5 , 2 , 2.5 , 3 , 3.5, 4\}$</p>
</div>
<p>$X_{i}$ deve ser maior ou igual a 0 e limitamos os valores para $\{0, 0.5, 1, 1.5 , 2 , 2.5 , 3 , 3.5, 4\}$ para impedir que um ovo tenha 1.01 ou 0.02 de quantidade e no máximo 4  quantidades do alimento para não sair uma dieta com poucos ou um alimento.</p>
<p> </p>
<p> </p>
<p> </p>
            ]]>
        </content>
    </entry>
    <entry>
        <title>O CVXPY para o problema de mochila (knapsack)</title>
        <author>
            <name>Fabio</name>
        </author>
        <link href="https://fabiovila.github.io/o-cvxpy-para-o-problema-de-mochila-knapsack.html"/>
        <id>https://fabiovila.github.io/o-cvxpy-para-o-problema-de-mochila-knapsack.html</id>
            <category term="python"/>
            <category term="otimização"/>
            <category term="cvxpy"/>

        <updated>2021-06-02T13:47:21-03:00</updated>
            <summary>
                <![CDATA[
                        <img src="https://fabiovila.github.io/media/posts/1/Screenshot-from-2021-05-15-17-39-07-2.png" alt="" />
                    CVXPY CVXPY é um framework python para diversos otimizadores com uma linguagem&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                    <img src="https://fabiovila.github.io/media/posts/1/Screenshot-from-2021-05-15-17-39-07-2.png" alt="" />
                <h2>CVXPY</h2>
<p>CVXPY é um framework python para diversos otimizadores com uma linguagem própria e suporte a Numpy.</p>
<p>Para instalar o CVXPY use o pip:</p>
<p><code class="language-bash">pip install cvxpy</code></p>
<p>Um dos otimizadores disponíveis é o <a href="https://projects.coin-or.org/Cbc" target="_blank" rel="noopener noreferrer">CBC</a>  um otimizador de programação linear inteiro open-source. O CBC pode ser usado em linha de comando sem ser necessário o CVXPY, mas neste caso será necessário aprender sua linguagem de entrada. </p>
<p>Também será necessário instalar o CVXOPT:</p>
<p><code class="language-bash">pip install cvxopt</code></p>
<h2>Problema da mochila</h2>
<p>O problema da mochila mais conhecido como knapsack é um problema clássico de otimização combinatória.</p>
<p>O problema consiste em colocar o maior valor possível de itens em uma mochila com certa capacidade de peso. A mochila tem uma capacidade definida de peso. Os itens um peso e um valor. A objetivo é ter o maior valor possível dentro da mochila, ou seja, maximizar o valor.</p>
<p>Esse problema aparece em diversas áreas como a logística, computação e investimentos.</p>
<pre><code class="language-python">import cvxpy as cp
import numpy as np
# Dados de entrada do problema
Valores = np.array([10,13,1,100,45,13,156,76,4,59,97,99])
Pesos = np.array([50,55,10,5,1,98,34,3,9,3,7,19])
Capacidade_Mochila = 100<br>
# Variaveis de decisão<br>
# Cada Item Xi terá valor 1 se estiver na mochila ou 0 se estiver fora
# cp.Variable cria uma variável no CVX ( não confunda cp com np ) do tipo boolean do tamanho da quantidade de itens
<br>Xi = cp.Variable((Valores.size), boolean = True)
<br># Constraints do problema<br>
# A soma total dos pesos dos itens escolhidos por Xi devem ser igual ou menor que a capacidade da mochila                
<br>constraints = [ Xi @ Pesos &lt;= Capacidade_Mochila ]
# Tambem pode ser escrito com o mesmo resultado como:
#constraints = [ cp.sum( cp.multiply (Xi, Pesos ) ) &lt;= Capacidade_Mochila ]
<br># O Objetivo do problema
# é maximizar os valores na mochila<br>
objective = cp.Maximize( Xi @ Valores )
<br># finalmente chamamos o solver com verbose para acompanhar 
# o progresso e a execução máxima de 1hr<br>
prob = cp.Problem(objective, constraints)              
prob.solve(solver=cp.CBC,verbose=True, maximumSeconds = 1 * 60 * 60)         
print("Status          : ", prob.status)
print("Valor encontrado: ", prob.value)
print("Valor de Xi     : ", Xi.value)
    </code></pre>
<p>O problema da mochila tem muitas aplicações práticas principalmente na logística. Imagine uma transportadora que precisa distribuir seus pacotes utilizando vans e caminhões. Cada pacote tem peso, tamanho, localidade, tempo de espera e valor. Um programa de otimização pode ajudar no preenchimento dos caminhões e em aplicações profissionais traçar a rota de distribuição de cada veículo.</p>
<p>Problemas de otimização não acham o melhor valor, porque em geral é uma tarefa impossível (o mais correto seria improvável) de acha-lo devido a explosão combinatória. Por isso são chamados 'otimizadores' porque eles buscam a melhor solução possível, ou seja, uma solução ótima.</p>
            ]]>
        </content>
    </entry>
</feed>

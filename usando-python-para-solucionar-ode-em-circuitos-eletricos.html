<!DOCTYPE html><html lang="pt-br"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="stylesheet" href="https://fabiovila.github.io/assets/css/high/github.css?v=754087c48785d8bc80b61b25cfa9f397"><script src="https://fabiovila.github.io/assets/js/highlight.min.js?v=794898ca191671a50f3d9908f4fa4815"></script><title>Usando Python para ODEs de circuitos elétricos: RL - Fabio</title><meta name="description" content="Neste primeiro post iniciarei uma série tratando da solução de circuitos elétricos&hellip;"><meta name="generator" content="Publii Open-Source CMS for Static Site"><link rel="canonical" href="https://fabiovila.github.io/usando-python-para-solucionar-ode-em-circuitos-eletricos.html"><link rel="alternate" type="application/atom+xml" href="https://fabiovila.github.io/feed.xml"><link rel="alternate" type="application/json" href="https://fabiovila.github.io/feed.json"><meta property="og:title" content="Usando Python para ODEs de circuitos elétricos: RL"><meta property="og:image" content="https://fabiovila.github.io/media/website/fabio.png"><meta property="og:site_name" content="Fabio"><meta property="og:description" content="Neste primeiro post iniciarei uma série tratando da solução de circuitos elétricos&hellip;"><meta property="og:url" content="https://fabiovila.github.io/usando-python-para-solucionar-ode-em-circuitos-eletricos.html"><meta property="og:type" content="article"><style>:root{--body-font:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen,Ubuntu,Cantarell,"Fira Sans","Droid Sans","Helvetica Neue",Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol";--heading-font:var(--body-font);--logo-font:var(--body-font);--menu-font:var(--body-font)}</style><link rel="stylesheet" href="https://fabiovila.github.io/assets/css/style.css?v=66b7f4f71a7da206ce9d5ad4b49d8b0d"><script type="application/ld+json">{"@context":"http://schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"https://fabiovila.github.io/usando-python-para-solucionar-ode-em-circuitos-eletricos.html"},"headline":"Usando Python para ODEs de circuitos elétricos: RL","datePublished":"2021-12-18T20:37","dateModified":"2022-01-16T14:33","image":{"@type":"ImageObject","url":"https://fabiovila.github.io/media/website/fabio.png","height":69,"width":70},"description":"Neste primeiro post iniciarei uma série tratando da solução de circuitos elétricos&hellip;","author":{"@type":"Person","name":"Fabio","url":"https://fabiovila.github.io/authors/fabio/"},"publisher":{"@type":"Organization","name":"Fabio","logo":{"@type":"ImageObject","url":"https://fabiovila.github.io/media/website/fabio.png","height":69,"width":70}}}</script><script>MathJax = {
  tex: {
    inlineMath: [['$', '$']]
  }
};</script><script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script><script>hljs.highlightAll();</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-PY9DT1RWSW"></script><script>window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-PY9DT1RWSW');</script></head><body><div class="container"><header class="header"><a href="https://fabiovila.github.io/" class="logo"><img src="https://fabiovila.github.io/media/website/fabio.png" alt="Fabio"></a></header><main><article class="post wrapper"><header class="hero"><p class="post__meta">By <a href="https://fabiovila.github.io/authors/fabio/" rel="author" title="Fabio">Fabio</a> Published on <time datetime="2021-12-18T20:37">dezembro 18, 2021</time></p><h1 class="post__title">Usando Python para ODEs de circuitos elétricos: RL</h1></header><div class="post__entry"><p>Neste primeiro post iniciarei uma série tratando da solução de circuitos elétricos utilizando Python. A solução analítica será encontrada utilizando SymPy um pacote de matemática simbólica. A solução numérica, onde podemos plotar gráficos e estudar valores iniciais diferentes rapidamente, será obtida com SciPy e Numpy. </p><p>Neste post tratarei apenas do circuito RL da figura abaixo pois encontramos neste tipo de circuito apenas uma derivada. Estudaremos os casos para fontes DC e AC.</p><figure class="post__image align-center"><img loading="lazy" src="https://fabiovila.github.io/media/posts/10/circuit.png" sizes="(max-width: 1024px) 100vw, 1024px" srcset="https://fabiovila.github.io/media/posts/10/responsive/circuit-xs.png 300w, https://fabiovila.github.io/media/posts/10/responsive/circuit-sm.png 480w, https://fabiovila.github.io/media/posts/10/responsive/circuit-md.png 768w, https://fabiovila.github.io/media/posts/10/responsive/circuit-lg.png 1024w" alt="" width="260" height="180"></figure><p>Para uma fonte DC de 5V o circuito é modelado pela seguinte equação diferencial</p><p class="msg msg--highlight">$\displaystyle 5 = 4700 i{\left(t \right)} + 0.0001 \frac{d}{d t} i{\left(t \right)}$</p><p>Esse tipo de equação é conhecida como Equações Diferenciais Ordinárias ou abreviadamente ODE e essas equações podem ter soluções analíticas ou numéricas. A solução analítica é a solução como conhecemos na escola ou a simples solução algébrica através de manipulação dos símbolos onde obteremos no final uma família de funções matemáticas em que podemos calcular o comportamento do circuito. Obter a solução analítica de uma ODE requer conhecimentos de cálculo 1 e 2 lecionado no nível superior, mas utilizando algum CAS (Computer Álgebra System) a solução é encontrada rapidamente.</p><p>A solução numérica não manipula símbolos, utiliza-se de métodos interativos com tentativa e erros com um certo discernimento de para onde ir em busca da solução. Pode ser feito na mão ou mais adequadamente no computador.</p><h4>Requerimentos</h4><p>Serão utilizados neste artigo os pacotes <strong>SymPy</strong>, <strong>Numpy</strong>, <strong>Matplotlib</strong> e <strong>SciPy </strong>que podem ser facilmente instalados utilizando o pip:</p><pre><code class="language-python">pip install sympy numpy matplotlib scipy</code></pre><ul><li><strong>Sympy</strong> - Pacote de computação matemática simbólica</li><li><strong>Numpy</strong> - Pacote de manipulação de vetores e matrizes e operações matemáticas em geral compilado com o OpenBLAS. Praticamente utilizado por todos os outros pacotes.</li><li><strong>Matplotlib </strong>- Exibe gráficos.</li><li><strong>Scipy </strong>- Um grande pacote com diversas utilidades em vários ramos da ciência.</li></ul><p>Em todos os arquivos os imports necessários e a cabeça do arquivo será este:</p><pre><code class="language-python">from sympy import *
import numpy as np
from scipy.integrate import solve_ivp
import matplotlib.pyplot as plt
%matplotlib inline
</code></pre><h4>Versão analítica com SymPy</h4><p>A solução analítica pode ser encontrada utilizando o módulo Sympy. É um módulo promissor, mas ainda está em um nível intermediário de maturidade. Não se compara em poder ao Maxima e ao Mathematica.</p><p>A solução analítica de uma ODE utilizando o Sympy é encontrada com o comando <code>dsolve</code>.</p><pre><code class="language-python">
S = 5
R = 4700
L = 100e-6

t = Symbol('t')
v = Function('v')(t)
i = Function('i')(t)
    
eq = Eq(S,R*i+L*i.diff(t))
eq
</code></pre><p>O Sympy exibe em formato tex a equação acima como:</p><p class="msg msg--highlight">$\displaystyle 5 = 4700 i{\left(t \right)} + 0.0001 \frac{d}{d t} i{\left(t \right)}$</p><p>E como dito a solução analítica é encontrada pelo comando <code>dsolve</code>: </p><pre><code class="language-python">dsolve(eq)
</code></pre><p>cuja saída será:</p><p class="msg msg--highlight">$\displaystyle i{\left(t \right)} = C_{1} e^{- 47000000.0 t} + \frac{1}{940}$</p><p>Que é a função de <strong>i em t </strong>como desejamos. C_1 é uma constante que como toda equação diferencial e sistemas físicos que armazenam energia essa constante define a condição inicial da função, oras, temos um indutor no circuito que INICIALMENTE pode ter um campo magnético de valor 0 ou qualquer outro valor que iria interferir no início do circuito. Cabe a nós dizer qual é esse campo. Mas em geral começamos com condições iniciais com corrente zero, ou seja, <strong>i(t=0) = 0</strong>.</p><h4>Versão numérica com SciPy e Numpy</h4><p><em>Sim é muito Py. Pois este é poder do Python: Seus módulos! E as pessoas gostam de homenagear o Python colocando o Py no nome.</em></p><p>A solução numérica será encontrada utilizando o comando <code>solve_ivp</code> porém o correto agora é dizer "as soluções" pois o que obteremos é uma tabela (List) com os valores numéricos de <strong>i em t </strong>que utilizaremos para visualizar o gráfico do comportamento da corrente no circuito.</p><pre><code class="language-python">def circuito(t,i):
    return (5 -4700*i)/0.0001
    
tempo_maximo = 0.000001
t = np.linspace(0,tempo_maximo,1000)
sol = solve_ivp(circuito,[0,tempo_maximo],[0],method='RK45',t_eval=t)
plt.plot(sol.t,sol.y[0])
</code></pre><p>O <code>solve_ivp</code> precisa que a equação esteja no formato $${dy \over dt}= ...$$ que no nosso caso então seria $${di \over dt}= ...$$ e que esta equação esteja em forma de função Python, dessa forma definimos então <code>def circuito(t,i):</code>.</p><p>O primeiro parâmetro de <code>solve_ivp</code> é nossa função, o segundo o intervalo de tempo que a ODE será integrada e o [0] é o valor inicial e como foi dito antes a corrente no circuito inicialmente é zero, ou seja [0].</p><p><strong>Tempo_maximo</strong> é crítico. Se um valor maior que o transitório do circuito for colocado não visualizaremos nada de útil, somente o estado estacionário do circuito. Se for muito pequeno veremos apenas o início do estado transitório que provavelmente será uma reta. Com os valores do programa o seguinte gráfico aparecerá:</p><figure class="post__image"><img loading="lazy" src="https://fabiovila.github.io/media/posts/10/output_11_1.png" sizes="(max-width: 1024px) 100vw, 1024px" srcset="https://fabiovila.github.io/media/posts/10/responsive/output_11_1-xs.png 300w, https://fabiovila.github.io/media/posts/10/responsive/output_11_1-sm.png 480w, https://fabiovila.github.io/media/posts/10/responsive/output_11_1-md.png 768w, https://fabiovila.github.io/media/posts/10/responsive/output_11_1-lg.png 1024w" alt="" width="391" height="261"></figure><p>Como a fonte é contínua o gráfico se apresenta como o esperado. A corrente começa do zero e vai subindo gradativamente até que o indutor seja somente um curto-circuito e a corrente circulante seja a limitada pelo resistor.</p><h4>Fonte de tensão senoidal</h4><p>Um circuito de corrente contínua não nos oferece muito. Vamos então usar uma fonte de tensão de 1Khz com Vp de 5V.</p><h5>Solução analítica</h5><pre><code class="language-python">
S = 5*sin(t*(2*pi/(1/1000)))
R = 4700
L = 100e-6

t = Symbol('t')
v = Function('v')(t)
i = Function('i')(t)
    
eq = Eq(S,R*i+L*i.diff(t))
eq
dsolve(eq)
</code></pre><p>A única diferença é a mudança do <strong>S </strong>com a senoide provida pelo Seno do SymPy <code>sin</code>. As saídas serão então:</p><p>$\displaystyle 5 \sin{\left(2000 \pi t \right)} = 4700 i{\left(t \right)} + 0.0001 \frac{d}{d t} i{\left(t \right)}$</p><p>E a solução </p><p>$\displaystyle i{\left(t \right)} = C_{1} e^{- 47000000.0 t} + 0.00106382976822168 \sin{\left(2000 \pi t \right)} - 1.42217863170866 \cdot 10^{-7} \cos{\left(2000 \pi t \right)} $</p><p>Basicamente uma corrente não defasada com <strong>1.06mA</strong>. Não entendi o outro cos de valor irrisório. Provavelmente o transitório inicial não seja uma composição pura do exponente e o sin, mas tenha algum componente que deforme a onda (Fourier).</p><h5>Solução numérica</h5><p>Já na solução numérica faremos maiores alterações.</p><pre><code class="language-python">
def circuito(t,i):
    return (5*np.sin(t*(2*np.pi/0.0001)) -4700*i)/0.0001
    
tempo_maximo = 0.001
t = np.linspace(0,tempo_maximo,10000)
sol = solve_ivp(circuito,[0,tempo_maximo],[0],method='RK45',t_eval=t)
print(max(sol.y[0]),min(sol.y[0]))

plt.subplots(figsize=(15, 5))
plt.subplot(1, 2, 1)
plt.plot(sol.t,sol.y[0])
plt.subplot(1, 2, 2)
plt.plot(t,5*np.sin(t*(2*np.pi/0.0001)))
</code></pre><p>As alterações, além da fonte, foi o tempo que foi diminuído e exibimos o i máximo e mínimo</p><p class="msg msg--highlight">0.0010661978534370956 -0.0010652848773317844</p><p>Nos gráficos abaixo o primeiro é a corrente do circuito encontrada pela solução numérica e o outro a tensão da fonte.</p><figure class="post__image"><img loading="lazy" src="https://fabiovila.github.io/media/posts/10/output_22_1.png" sizes="(max-width: 1024px) 100vw, 1024px" srcset="https://fabiovila.github.io/media/posts/10/responsive/output_22_1-xs.png 300w, https://fabiovila.github.io/media/posts/10/responsive/output_22_1-sm.png 480w, https://fabiovila.github.io/media/posts/10/responsive/output_22_1-md.png 768w, https://fabiovila.github.io/media/posts/10/responsive/output_22_1-lg.png 1024w" alt="" width="902" height="303"></figure><p>Os valores mínimos e máximos mostram uma corrente de <strong>1.06mA </strong>que confere com a solução analítica obtida anteriormente.</p><h4>Falstad</h4><p>Vamos conferir com o simulador de circuitos do <a href="#INTERNAL_LINK#/post/null" title="https://falstad.com/circuit/" target="_blank" rel="noopener noreferrer">Falstad</a>? Que aliás usa de muita solução numérica para simular o circuito.</p><figure class="post__image"><img loading="lazy" src="https://fabiovila.github.io/media/posts/10/Captura-de-tela-de-2021-12-18-20-34-51.png" sizes="(max-width: 1024px) 100vw, 1024px" srcset="https://fabiovila.github.io/media/posts/10/responsive/Captura-de-tela-de-2021-12-18-20-34-51-xs.png 300w, https://fabiovila.github.io/media/posts/10/responsive/Captura-de-tela-de-2021-12-18-20-34-51-sm.png 480w, https://fabiovila.github.io/media/posts/10/responsive/Captura-de-tela-de-2021-12-18-20-34-51-md.png 768w, https://fabiovila.github.io/media/posts/10/responsive/Captura-de-tela-de-2021-12-18-20-34-51-lg.png 1024w" alt="" width="636" height="465"></figure><p>Como se pode ver no osciloscópio <strong>Fonte CA</strong> o <strong>Max=1.064mA</strong> bate com nossos cálculos.</p><p><a href="https://fabiovila.github.io/RL.ipynb" target="_blank" rel="noopener noreferrer">Link para o ipynb (Jupyter Notebook) deste post.</a></p><p>Espero que tenham gostado. Em breve novos posts!</p><p> </p><p> </p></div><footer class="post__footer"><div class="post__last-updated">This article was updated on janeiro 16, 2022</div><div class="post__footer__col"><ul class="post__tag"><li><a href="https://fabiovila.github.io/calculo-numerico/">cálculo numérico</a></li><li><a href="https://fabiovila.github.io/eletronica/">eletrônica</a></li><li><a href="https://fabiovila.github.io/modelagem-matematica/">modelagem-matemática</a></li><li><a href="https://fabiovila.github.io/ode/">ODE</a></li><li><a href="https://fabiovila.github.io/python/">python</a></li></ul><div class="post__share"><a href="https://api.whatsapp.com/send?text=Usando%20Python%20para%20ODEs%20de%20circuitos%20el%C3%A9tricos%3A%20RL https%3A%2F%2Ffabiovila.github.io%2Fusando-python-para-solucionar-ode-em-circuitos-eletricos.html" class="js-share whatsapp" aria-label="Share with Whats App" rel="nofollow noopener noreferrer"><svg class="icon"><use xlink:href="https://fabiovila.github.io/assets/svg/svg-map.svg#whatsapp"/></svg></a></div></div><nav class="post__nav"><div class="post__nav__prev">Previous Post<h5><a href="https://fabiovila.github.io/probabilidade-classica-frequentista-e-subjetiva.html" class="inverse" rel="prev">Probabilidade Clássica, frequentista e subjetiva</a></h5></div><div class="post__nav__next">Next Post<h5><a href="https://fabiovila.github.io/lista-de-codigos-obd2.html" class="inverse" rel="next">Lista de códigos OBD2</a></h5></div></nav><div class="post__bio"><div><h3><a href="https://fabiovila.github.io/authors/fabio/" class="inverse" title="Fabio">Fabio</a></h3></div></div><div class="post__related"><h3 class="u-h5">Related posts</h3><div class="post__related__wrap"><figure><figcaption><h4><a href="https://fabiovila.github.io/usando-raspberry-pi-como-servidor-syslog-remoto-para-roteador-claronet.html" class="inverse">Usando Raspberry Pi como servidor syslog remoto para roteador Claro/NET</a></h4><time datetime="2021-07-09T20:56">julho 9, 2021</time></figcaption></figure><figure><a href="https://fabiovila.github.io/rede-neural-em-python-numpy-para-iris-dataset.html"><img src="https://fabiovila.github.io/media/posts/6/responsive/Captura-de-tela-de-2021-06-02-14-23-17-xs.png" loading="lazy" alt=""></a><figcaption><h4><a href="https://fabiovila.github.io/rede-neural-em-python-numpy-para-iris-dataset.html" class="inverse">Rede neural em python numpy para iris dataset</a></h4><time datetime="2021-06-02T11:41">junho 2, 2021</time></figcaption></figure><figure><a href="https://fabiovila.github.io/o-cvxpy-para-o-problema-de-mochila-knapsack.html"><img src="https://fabiovila.github.io/media/posts/1/responsive/Screenshot-from-2021-05-15-17-39-07-2-xs.png" loading="lazy" alt=""></a><figcaption><h4><a href="https://fabiovila.github.io/o-cvxpy-para-o-problema-de-mochila-knapsack.html" class="inverse">O CVXPY para o problema de mochila (knapsack)</a></h4><time datetime="2020-07-26T15:35">julho 26, 2020</time></figcaption></figure></div></div></footer></article></main><div id="disqus_thread"></div><script>var disqus_config = function () {
    this.page.url = "";  
    this.page.identifier = ""; 
    };
    (function() { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');
    s.src = 'https://fabiovila-io.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
    })();</script><noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript><footer class="footer"><div class="footer__copyright">Powered by <a href="https://getpublii.com" target="_blank" rel="nofollow noopener">Publii</a></div></footer></div><script>window.publiiThemeMenuConfig={mobileMenuMode:'sidebar',animationSpeed:300,submenuWidth: 'auto',doubleClickTime:500,mobileMenuExpandableSubmenus:true,relatedContainerForOverlayMenuSelector:'.navbar'};</script><script>/*<![CDATA[*/var images=document.querySelectorAll("img[loading]");for(var i=0;i<images.length;i++){if(images[i].complete){images[i].classList.add("is-loaded")}else{images[i].addEventListener("load",function(){this.classList.add("is-loaded")},false)}};/*]]>*/</script></body></html>
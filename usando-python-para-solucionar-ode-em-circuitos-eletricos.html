<!DOCTYPE html><html lang="pt-br"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="stylesheet" href="https://fabiovila.github.io/assets/css/high/github.css?v=754087c48785d8bc80b61b25cfa9f397"><script src="https://fabiovila.github.io/assets/js/highlight.min.js?v=794898ca191671a50f3d9908f4fa4815"></script><title>Usando Python para solucionar ODE em circuitos elétricos: RL - Fabio</title><meta name="description" content="Neste primeiro post iniciarei uma série de posts tratando da solução de&hellip;"><meta name="generator" content="Publii Open-Source CMS for Static Site"><link rel="canonical" href="https://fabiovila.github.io/usando-python-para-solucionar-ode-em-circuitos-eletricos.html"><link rel="alternate" type="application/atom+xml" href="https://fabiovila.github.io/feed.xml"><link rel="alternate" type="application/json" href="https://fabiovila.github.io/feed.json"><meta property="og:title" content="Usando Python para solucionar ODE em circuitos elétricos: RL"><meta property="og:site_name" content="Fabio"><meta property="og:description" content="Neste primeiro post iniciarei uma série de posts tratando da solução de&hellip;"><meta property="og:url" content="https://fabiovila.github.io/usando-python-para-solucionar-ode-em-circuitos-eletricos.html"><meta property="og:type" content="article"><style>:root{--body-font:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen,Ubuntu,Cantarell,"Fira Sans","Droid Sans","Helvetica Neue",Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol";--heading-font:var(--body-font);--logo-font:var(--body-font);--menu-font:var(--body-font)}</style><link rel="stylesheet" href="https://fabiovila.github.io/assets/css/style.css?v=769d7954b2b61cff57f960f9c5e4e9fd"><script type="application/ld+json">{"@context":"http://schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"https://fabiovila.github.io/usando-python-para-solucionar-ode-em-circuitos-eletricos.html"},"headline":"Usando Python para solucionar ODE em circuitos elétricos: RL","datePublished":"2021-12-18T20:37","dateModified":"2021-12-18T22:53","description":"Neste primeiro post iniciarei uma série de posts tratando da solução de&hellip;","author":{"@type":"Person","name":"Fabio"},"publisher":{"@type":"Organization","name":"Fabio"}}</script><script>MathJax = {
  tex: {
    inlineMath: [['$', '$']]
  }
};</script><script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script><script>hljs.highlightAll();</script></head><body><div class="container"><header class="header"><a href="https://fabiovila.github.io/" class="logo">Fabio</a></header><main><article class="post wrapper"><header class="hero"><p class="post__meta">By <a href="https://fabiovila.github.io/authors/fabio/" rel="author" title="Fabio">Fabio</a> Published on <time datetime="2021-12-18T20:37">dezembro 18, 2021</time></p><h1 class="post__title">Usando Python para solucionar ODE em circuitos elétricos: RL</h1></header><div class="post__entry"><p>Neste primeiro post iniciarei uma série de posts tratando da solução de circuitos elétricos utilizando Python. Um bom início é o circuito RL pois encontramos nele apenas uma derivada.</p><figure class="post__image align-center"><img loading="lazy" src="https://fabiovila.github.io/media/posts/10/circuit.png" sizes="(max-width: 1024px) 100vw, 1024px" srcset="https://fabiovila.github.io/media/posts/10/responsive/circuit-xs.png 300w, https://fabiovila.github.io/media/posts/10/responsive/circuit-sm.png 480w, https://fabiovila.github.io/media/posts/10/responsive/circuit-md.png 768w, https://fabiovila.github.io/media/posts/10/responsive/circuit-lg.png 1024w" alt="" width="260" height="180"></figure><br><br>Para uma fonte de 5V o circuito é modelado pela seguinte equação diferencial<p></p><p class="msg msg--highlight">$\displaystyle 5 = 4700 i{\left(t \right)} + 0.0001 \frac{d}{d t} i{\left(t \right)}$</p><p> </p><p>Posteriormente iremos usar uma fonte CA senoidal.</p><p>Conhecidas como Equações Diferenciais Ordinárias ou abreviadamente ODE essas equações podem ter soluções analítica ou numérica. A solução analítica é a solução como conhecemos na escola ou a simples solução algébrica através de manipulação dos símbolos. Entretanto a solução analítica de uma ODE requer conhecimento de cálculo 2 lecionado no nível superior. </p><p>A solução numérica não manipula símbolos, utiliza-se de métodos interativos com tentativa e erros com um certo discernimento de para onde ir em busca da solução. </p><p>Veremos neste post os dois métodos utilizando Python. Primeiro faremos alguns imports.</p><pre><code class="language-python">
from sympy import *
import numpy as np
from scipy.integrate import solve_ivp
import matplotlib.pyplot as plt
%matplotlib inline
</code></pre><h4>Versão analítica com SymPy</h4><p>A solução analítica pode ser encontrada utilizando o módulo Sympy. É um módulo promissor, mas ainda está em um nível intermediário de maturidade. Não se compara em poder ao Maxima e o Mathematica.</p><p>A solução analítica de uma ODE utilizando o Sympy é encontrada com o comando <code>dsolve</code>.</p><pre><code class="language-python">
S = 5
R = 4700
L = 100e-6

t = Symbol('t')
v = Function('v')(t)
i = Function('i')(t)
    
eq = Eq(S,R*i+L*i.diff(t))
eq
</code></pre><p>O Sympy exibe em formato tex a equação acima como:</p><p class="msg msg--highlight">$\displaystyle 5 = 4700 i{\left(t \right)} + 0.0001 \frac{d}{d t} i{\left(t \right)}$</p><p>E como dito a solução analítica é encontrada pelo comando <code>dsolve</code>: </p><pre><code class="language-python">dsolve(eq)
</code></pre><p>cuja saída será:</p><p class="msg msg--highlight">$\displaystyle i{\left(t \right)} = C_{1} e^{- 47000000.0 t} + \frac{1}{940}$</p><p>Que é a função de <strong>i em t </strong>como desejamos. C_1 é uma constante que como toda equação diferencial e sistemas físicos que armazenam energia essa constante define a condição inicial da função, oras, temos um indutor no circuito que INICIALMENTE pode ter um campo magnético de valor 0 ou qualquer outro valor que iria interferir no início do circuito. Cabe a nós dizer qual é esse campo. Mas em geral começamos com condições iniciais com corrente zero, ou seja, <strong>i(t=0) = 0</strong>.</p><h4>Versão numérica com SciPy e Numpy</h4><p><em>Sim é muito Py. Pois este é poder do Python: Seus módulos! E as pessoas gostam de homenagear o Python colocando o Py no nome.</em></p><p>A solução numérica será encontrada utilizando o comando <code>solve_ivp</code> porém o correto agora é dizer "as soluções" pois o que obteremos é uma tabela (List) com os valores numéricos de <strong>i em t </strong>que utilizaremos para visualizarmos o gráfico do comportamento da corrente no circuito.</p><pre><code class="language-python">def circuito(t,i):
    return (5 -4700*i)/0.0001
    
tempo_maximo = 0.000001
t = np.linspace(0,tempo_maximo,1000)
sol = solve_ivp(circuito,[0,tempo_maximo],[0],method='RK45',t_eval=t)
plt.plot(sol.t,sol.y[0])
</code></pre><p>O <code>solve_ivp</code> precisa que a equação esteja no formato $${dy \over dt}= ...$$ que no nosso caso então seria $${di \over dt}= ...$$ e que esta equação esteja em forma de função Python. Definimos, então, <code>def circuito(t,i):</code>.</p><p>O primeiro parâmetro de <code>solve_ivp</code> é nossa função, o segundo o intervalo de tempo que a ODE será integrada e o [0] é o valor inicial e como foi dito antes a corrente no circuito inicialmente é zero, ou seja, [0].</p><p><strong>Tempo_maximo</strong> é crítico. Se um valor maior que o transitório do circuito for colocado não visualizaremos nada de útil, somente o estado estacionário do circuito. Se for muito pequeno veremos apenas o início do estado transitório que provavelmente será uma reta. Com esse valores o seguinte gráfico se apresenta:</p><figure class="post__image"><img loading="lazy" src="https://fabiovila.github.io/media/posts/10/output_11_1.png" sizes="(max-width: 1024px) 100vw, 1024px" srcset="https://fabiovila.github.io/media/posts/10/responsive/output_11_1-xs.png 300w, https://fabiovila.github.io/media/posts/10/responsive/output_11_1-sm.png 480w, https://fabiovila.github.io/media/posts/10/responsive/output_11_1-md.png 768w, https://fabiovila.github.io/media/posts/10/responsive/output_11_1-lg.png 1024w" alt="" width="391" height="261"></figure><p>E finalmente algo visual. Como a fonte é contínua o gráfico se apresenta como o esperado. A corrente começa do zero e vai subindo gradativamente até que o indutor seja somente um curto-circuito e a corrente circulante seja a limitada pelo resistor.</p><h4>Fonte de tensão senoidal</h4><p>Um circuito de corrente contínua não nos oferece muito. Vamos então usar uma fonte de tensão de 1Khz com Vp de 5V.</p><h5>Solução analítica</h5><pre><code class="language-python">
S = 5*sin(t*(2*pi/(1/1000)))
R = 4700
L = 100e-6

t = Symbol('t')
v = Function('v')(t)
i = Function('i')(t)
    
eq = Eq(S,R*i+L*i.diff(t))
eq
dsolve(eq)
</code></pre><p>A única diferença é a mudança do <strong>S </strong>com a senoide provida pelo Seno do SymPy <code>sin</code>. As saídas serão então:</p><p>$\displaystyle 5 \sin{\left(2000 \pi t \right)} = 4700 i{\left(t \right)} + 0.0001 \frac{d}{d t} i{\left(t \right)}$</p><p>E a solução </p><p>$\displaystyle i{\left(t \right)} = C_{1} e^{- 47000000.0 t} + 0.00106382976822168 \sin{\left(2000 \pi t \right)} - 1.42217863170866 \cdot 10^{-7} \cos{\left(2000 \pi t \right)} $</p><p>Basicamente uma corrente não defasada com 1.06mA. Não entendi o outro cos de valor irrisório. Provavelmente o transitório inicial não seja uma composição pura do exponente e o sin, mas tenha algum componente que deforme a onda (Fourier).</p><h5>Solução numérica</h5><p>Na solução numérica faremos maiores alterações.</p><pre><code class="language-python">
def circuito(t,i):
    return (5*np.sin(t*(2*np.pi/0.0001)) -4700*i)/0.0001
    
tempo_maximo = 0.001
t = np.linspace(0,tempo_maximo,10000)
sol = solve_ivp(circuito,[0,tempo_maximo],[0],method='RK45',t_eval=t)
print(max(sol.y[0]),min(sol.y[0]))

plt.subplots(figsize=(15, 5))
plt.subplot(1, 2, 1)
plt.plot(sol.t,sol.y[0])
plt.subplot(1, 2, 2)
plt.plot(t,5*np.sin(t*(2*np.pi/0.0001)))
</code></pre><p>As alterações além da fonte foram o tempo que foi diminuído, exibimos o i máximo e mínimo</p><p class="msg msg--highlight">0.0010661978534370956 -0.0010652848773317844</p><p>para conferência. Bem como plotamos dois gráficos. O primeiro com a corrente do circuito e o outro com a tensão da fonte exibidos abaixo.</p><figure class="post__image"><img loading="lazy" src="https://fabiovila.github.io/media/posts/10/output_22_1.png" sizes="(max-width: 1024px) 100vw, 1024px" srcset="https://fabiovila.github.io/media/posts/10/responsive/output_22_1-xs.png 300w, https://fabiovila.github.io/media/posts/10/responsive/output_22_1-sm.png 480w, https://fabiovila.github.io/media/posts/10/responsive/output_22_1-md.png 768w, https://fabiovila.github.io/media/posts/10/responsive/output_22_1-lg.png 1024w" alt="" width="902" height="303"></figure><h4>Falstad</h4><p>Vamos conferir com o simulador de circuitos do <a href="#INTERNAL_LINK#/post/null" title="https://falstad.com/circuit/" target="_blank" rel="noopener noreferrer">Falstad</a>? Que aliás usa de muita solução numérica para simular o circuito.</p><figure class="post__image"><img loading="lazy" src="https://fabiovila.github.io/media/posts/10/Captura-de-tela-de-2021-12-18-20-34-51.png" sizes="(max-width: 1024px) 100vw, 1024px" srcset="https://fabiovila.github.io/media/posts/10/responsive/Captura-de-tela-de-2021-12-18-20-34-51-xs.png 300w, https://fabiovila.github.io/media/posts/10/responsive/Captura-de-tela-de-2021-12-18-20-34-51-sm.png 480w, https://fabiovila.github.io/media/posts/10/responsive/Captura-de-tela-de-2021-12-18-20-34-51-md.png 768w, https://fabiovila.github.io/media/posts/10/responsive/Captura-de-tela-de-2021-12-18-20-34-51-lg.png 1024w" alt="" width="636" height="465"></figure><p>Como se pode ver no osciloscópio <strong>Fonte CA</strong> o <strong>Max=1.064mA</strong> bate com nossos cálculos.</p><p>Espero que tenham gostado. Em breve novos posts!</p><p> </p><p> </p></div><footer class="post__footer"><div class="post__last-updated">This article was updated on dezembro 18, 2021</div><div class="post__footer__col"><div class="post__share"><a href="https://api.whatsapp.com/send?text=Usando%20Python%20para%20solucionar%20ODE%20em%20circuitos%20el%C3%A9tricos%3A%20RL https%3A%2F%2Ffabiovila.github.io%2Fusando-python-para-solucionar-ode-em-circuitos-eletricos.html" class="js-share whatsapp" aria-label="Share with Whats App" rel="nofollow noopener noreferrer"><svg class="icon"><use xlink:href="https://fabiovila.github.io/assets/svg/svg-map.svg#whatsapp"/></svg></a></div></div><nav class="post__nav"><div class="post__nav__prev">Previous Post<h5><a href="https://fabiovila.github.io/lista-com-1000000-de-numeros-e-seus-fatores-primos-e-se-sao-primos-ou-quadrados-perfeitos.html" class="inverse" rel="prev">Lista com 1000000 de números e seus fatores primos e se são primos ou quadrados perfeitos</a></h5></div></nav><div class="post__bio"><div><h3><a href="https://fabiovila.github.io/authors/fabio/" class="inverse" title="Fabio">Fabio</a></h3></div></div><div class="post__related"><h3 class="u-h5">Related posts</h3><div class="post__related__wrap"><figure><figcaption><h4><a href="https://fabiovila.github.io/usando-raspberry-pi-como-servidor-syslog-remoto-para-roteador-claronet.html" class="inverse">Usando Raspberry Pi como servidor syslog remoto para roteador Claro/NET</a></h4><time datetime="2021-07-09T20:56">julho 9, 2021</time></figcaption></figure><figure><a href="https://fabiovila.github.io/rede-neural-em-python-numpy-para-iris-dataset.html"><img src="https://fabiovila.github.io/media/posts/6/responsive/Captura-de-tela-de-2021-06-02-14-23-17-xs.png" loading="lazy" alt=""></a><figcaption><h4><a href="https://fabiovila.github.io/rede-neural-em-python-numpy-para-iris-dataset.html" class="inverse">Rede neural em python numpy para iris dataset</a></h4><time datetime="2021-06-02T11:41">junho 2, 2021</time></figcaption></figure><figure><a href="https://fabiovila.github.io/o-cvxpy-para-o-problema-de-mochila-knapsack.html"><img src="https://fabiovila.github.io/media/posts/1/responsive/Screenshot-from-2021-05-15-17-39-07-2-xs.png" loading="lazy" alt=""></a><figcaption><h4><a href="https://fabiovila.github.io/o-cvxpy-para-o-problema-de-mochila-knapsack.html" class="inverse">O CVXPY para o problema de mochila (knapsack)</a></h4><time datetime="2020-07-26T15:35">julho 26, 2020</time></figcaption></figure></div></div></footer></article></main><footer class="footer"><div class="footer__copyright">Powered by <a href="https://getpublii.com" target="_blank" rel="nofollow noopener">Publii</a></div></footer></div><script defer="defer" src="https://fabiovila.github.io/assets/js/scripts.min.js?v=c3bbc0611ea6a5405014eaca34fe1814"></script><script>window.publiiThemeMenuConfig={mobileMenuMode:'sidebar',animationSpeed:300,submenuWidth: 'auto',doubleClickTime:500,mobileMenuExpandableSubmenus:true,relatedContainerForOverlayMenuSelector:'.navbar'};</script><script>/*<![CDATA[*/var images=document.querySelectorAll("img[loading]");for(var i=0;i<images.length;i++){if(images[i].complete){images[i].classList.add("is-loaded")}else{images[i].addEventListener("load",function(){this.classList.add("is-loaded")},false)}};/*]]>*/</script></body></html>